{"ast":null,"code":"'use strict';\n\nconst CryptoProvider = require('./CryptoProvider');\n/**\n * `CryptoProvider which uses the SubtleCrypto interface of the Web Crypto API.\n *\n * This only supports asynchronous operations.\n */\nclass SubtleCryptoProvider extends CryptoProvider {\n  constructor(subtleCrypto) {\n    super();\n    // If no subtle crypto is interface, default to the global namespace. This\n    // is to allow custom interfaces (eg. using the Node webcrypto interface in\n    // tests).\n    this.subtleCrypto = subtleCrypto || crypto.subtle;\n  }\n  /** @override */\n  computeHMACSignature(payload, secret) {\n    throw new Error('SubtleCryptoProvider cannot be used in a synchronous context.');\n  }\n  /** @override */\n  async computeHMACSignatureAsync(payload, secret) {\n    const encoder = new TextEncoder();\n    const key = await this.subtleCrypto.importKey('raw', encoder.encode(secret), {\n      name: 'HMAC',\n      hash: {\n        name: 'SHA-256'\n      }\n    }, false, ['sign']);\n    const signatureBuffer = await this.subtleCrypto.sign('hmac', key, encoder.encode(payload));\n    // crypto.subtle returns the signature in base64 format. This must be\n    // encoded in hex to match the CryptoProvider contract. We map each byte in\n    // the buffer to its corresponding hex octet and then combine into a string.\n    const signatureBytes = new Uint8Array(signatureBuffer);\n    const signatureHexCodes = new Array(signatureBytes.length);\n    for (let i = 0; i < signatureBytes.length; i++) {\n      signatureHexCodes[i] = byteHexMapping[signatureBytes[i]];\n    }\n    return signatureHexCodes.join('');\n  }\n}\n// Cached mapping of byte to hex representation. We do this once to avoid re-\n// computing every time we need to convert the result of a signature to hex.\nconst byteHexMapping = new Array(256);\nfor (let i = 0; i < byteHexMapping.length; i++) {\n  byteHexMapping[i] = i.toString(16).padStart(2, '0');\n}\nmodule.exports = SubtleCryptoProvider;","map":{"version":3,"names":["CryptoProvider","require","SubtleCryptoProvider","constructor","subtleCrypto","crypto","subtle","computeHMACSignature","payload","secret","Error","computeHMACSignatureAsync","encoder","TextEncoder","key","importKey","encode","name","hash","signatureBuffer","sign","signatureBytes","Uint8Array","signatureHexCodes","Array","length","i","byteHexMapping","join","toString","padStart","module","exports"],"sources":["C:/Users/galia/OneDrive/Escritorio/rent-a-bike-app/node_modules/stripe/lib/crypto/SubtleCryptoProvider.js"],"sourcesContent":["'use strict';\nconst CryptoProvider = require('./CryptoProvider');\n/**\n * `CryptoProvider which uses the SubtleCrypto interface of the Web Crypto API.\n *\n * This only supports asynchronous operations.\n */\nclass SubtleCryptoProvider extends CryptoProvider {\n  constructor(subtleCrypto) {\n    super();\n    // If no subtle crypto is interface, default to the global namespace. This\n    // is to allow custom interfaces (eg. using the Node webcrypto interface in\n    // tests).\n    this.subtleCrypto = subtleCrypto || crypto.subtle;\n  }\n  /** @override */\n  computeHMACSignature(payload, secret) {\n    throw new Error(\n      'SubtleCryptoProvider cannot be used in a synchronous context.'\n    );\n  }\n  /** @override */\n  async computeHMACSignatureAsync(payload, secret) {\n    const encoder = new TextEncoder();\n    const key = await this.subtleCrypto.importKey(\n      'raw',\n      encoder.encode(secret),\n      {\n        name: 'HMAC',\n        hash: {name: 'SHA-256'},\n      },\n      false,\n      ['sign']\n    );\n    const signatureBuffer = await this.subtleCrypto.sign(\n      'hmac',\n      key,\n      encoder.encode(payload)\n    );\n    // crypto.subtle returns the signature in base64 format. This must be\n    // encoded in hex to match the CryptoProvider contract. We map each byte in\n    // the buffer to its corresponding hex octet and then combine into a string.\n    const signatureBytes = new Uint8Array(signatureBuffer);\n    const signatureHexCodes = new Array(signatureBytes.length);\n    for (let i = 0; i < signatureBytes.length; i++) {\n      signatureHexCodes[i] = byteHexMapping[signatureBytes[i]];\n    }\n    return signatureHexCodes.join('');\n  }\n}\n// Cached mapping of byte to hex representation. We do this once to avoid re-\n// computing every time we need to convert the result of a signature to hex.\nconst byteHexMapping = new Array(256);\nfor (let i = 0; i < byteHexMapping.length; i++) {\n  byteHexMapping[i] = i.toString(16).padStart(2, '0');\n}\nmodule.exports = SubtleCryptoProvider;\n"],"mappings":"AAAA,YAAY;;AACZ,MAAMA,cAAc,GAAGC,OAAO,CAAC,kBAAkB,CAAC;AAClD;AACA;AACA;AACA;AACA;AACA,MAAMC,oBAAoB,SAASF,cAAc,CAAC;EAChDG,WAAW,CAACC,YAAY,EAAE;IACxB,KAAK,EAAE;IACP;IACA;IACA;IACA,IAAI,CAACA,YAAY,GAAGA,YAAY,IAAIC,MAAM,CAACC,MAAM;EACnD;EACA;EACAC,oBAAoB,CAACC,OAAO,EAAEC,MAAM,EAAE;IACpC,MAAM,IAAIC,KAAK,CACb,+DAA+D,CAChE;EACH;EACA;EACA,MAAMC,yBAAyB,CAACH,OAAO,EAAEC,MAAM,EAAE;IAC/C,MAAMG,OAAO,GAAG,IAAIC,WAAW,EAAE;IACjC,MAAMC,GAAG,GAAG,MAAM,IAAI,CAACV,YAAY,CAACW,SAAS,CAC3C,KAAK,EACLH,OAAO,CAACI,MAAM,CAACP,MAAM,CAAC,EACtB;MACEQ,IAAI,EAAE,MAAM;MACZC,IAAI,EAAE;QAACD,IAAI,EAAE;MAAS;IACxB,CAAC,EACD,KAAK,EACL,CAAC,MAAM,CAAC,CACT;IACD,MAAME,eAAe,GAAG,MAAM,IAAI,CAACf,YAAY,CAACgB,IAAI,CAClD,MAAM,EACNN,GAAG,EACHF,OAAO,CAACI,MAAM,CAACR,OAAO,CAAC,CACxB;IACD;IACA;IACA;IACA,MAAMa,cAAc,GAAG,IAAIC,UAAU,CAACH,eAAe,CAAC;IACtD,MAAMI,iBAAiB,GAAG,IAAIC,KAAK,CAACH,cAAc,CAACI,MAAM,CAAC;IAC1D,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,cAAc,CAACI,MAAM,EAAEC,CAAC,EAAE,EAAE;MAC9CH,iBAAiB,CAACG,CAAC,CAAC,GAAGC,cAAc,CAACN,cAAc,CAACK,CAAC,CAAC,CAAC;IAC1D;IACA,OAAOH,iBAAiB,CAACK,IAAI,CAAC,EAAE,CAAC;EACnC;AACF;AACA;AACA;AACA,MAAMD,cAAc,GAAG,IAAIH,KAAK,CAAC,GAAG,CAAC;AACrC,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,cAAc,CAACF,MAAM,EAAEC,CAAC,EAAE,EAAE;EAC9CC,cAAc,CAACD,CAAC,CAAC,GAAGA,CAAC,CAACG,QAAQ,CAAC,EAAE,CAAC,CAACC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;AACrD;AACAC,MAAM,CAACC,OAAO,GAAG9B,oBAAoB"},"metadata":{},"sourceType":"script","externalDependencies":[]}