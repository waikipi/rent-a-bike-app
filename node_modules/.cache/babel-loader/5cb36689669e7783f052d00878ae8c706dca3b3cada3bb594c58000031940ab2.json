{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst InitFragment = require(\"../InitFragment\");\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst {\n  first\n} = require(\"../util/SetHelpers\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Generator\").GenerateContext} GenerateContext */\n\nconst joinIterableWithComma = iterable => {\n  // This is more performant than Array.from().join(\", \")\n  // as it doesn't create an array\n  let str = \"\";\n  let first = true;\n  for (const item of iterable) {\n    if (first) {\n      first = false;\n    } else {\n      str += \", \";\n    }\n    str += item;\n  }\n  return str;\n};\nconst EMPTY_MAP = new Map();\nconst EMPTY_SET = new Set();\n\n/**\n * @typedef {GenerateContext} Context\n */\nclass HarmonyExportInitFragment extends InitFragment {\n  /**\n   * @param {string} exportsArgument the exports identifier\n   * @param {Map<string, string>} exportMap mapping from used name to exposed variable name\n   * @param {Set<string>} unusedExports list of unused export names\n   */\n  constructor(exportsArgument) {\n    let exportMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EMPTY_MAP;\n    let unusedExports = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EMPTY_SET;\n    super(undefined, InitFragment.STAGE_HARMONY_EXPORTS, 1, \"harmony-exports\");\n    this.exportsArgument = exportsArgument;\n    this.exportMap = exportMap;\n    this.unusedExports = unusedExports;\n  }\n\n  /**\n   * @param {HarmonyExportInitFragment[]} fragments all fragments to merge\n   * @returns {HarmonyExportInitFragment} merged fragment\n   */\n  mergeAll(fragments) {\n    let exportMap;\n    let exportMapOwned = false;\n    let unusedExports;\n    let unusedExportsOwned = false;\n    for (const fragment of fragments) {\n      if (fragment.exportMap.size !== 0) {\n        if (exportMap === undefined) {\n          exportMap = fragment.exportMap;\n          exportMapOwned = false;\n        } else {\n          if (!exportMapOwned) {\n            exportMap = new Map(exportMap);\n            exportMapOwned = true;\n          }\n          for (const [key, value] of fragment.exportMap) {\n            if (!exportMap.has(key)) exportMap.set(key, value);\n          }\n        }\n      }\n      if (fragment.unusedExports.size !== 0) {\n        if (unusedExports === undefined) {\n          unusedExports = fragment.unusedExports;\n          unusedExportsOwned = false;\n        } else {\n          if (!unusedExportsOwned) {\n            unusedExports = new Set(unusedExports);\n            unusedExportsOwned = true;\n          }\n          for (const value of fragment.unusedExports) {\n            unusedExports.add(value);\n          }\n        }\n      }\n    }\n    return new HarmonyExportInitFragment(this.exportsArgument, exportMap, unusedExports);\n  }\n  merge(other) {\n    let exportMap;\n    if (this.exportMap.size === 0) {\n      exportMap = other.exportMap;\n    } else if (other.exportMap.size === 0) {\n      exportMap = this.exportMap;\n    } else {\n      exportMap = new Map(other.exportMap);\n      for (const [key, value] of this.exportMap) {\n        if (!exportMap.has(key)) exportMap.set(key, value);\n      }\n    }\n    let unusedExports;\n    if (this.unusedExports.size === 0) {\n      unusedExports = other.unusedExports;\n    } else if (other.unusedExports.size === 0) {\n      unusedExports = this.unusedExports;\n    } else {\n      unusedExports = new Set(other.unusedExports);\n      for (const value of this.unusedExports) {\n        unusedExports.add(value);\n      }\n    }\n    return new HarmonyExportInitFragment(this.exportsArgument, exportMap, unusedExports);\n  }\n\n  /**\n   * @param {Context} context context\n   * @returns {string|Source} the source code that will be included as initialization code\n   */\n  getContent(_ref) {\n    let {\n      runtimeTemplate,\n      runtimeRequirements\n    } = _ref;\n    runtimeRequirements.add(RuntimeGlobals.exports);\n    runtimeRequirements.add(RuntimeGlobals.definePropertyGetters);\n    const unusedPart = this.unusedExports.size > 1 ? `/* unused harmony exports ${joinIterableWithComma(this.unusedExports)} */\\n` : this.unusedExports.size > 0 ? `/* unused harmony export ${first(this.unusedExports)} */\\n` : \"\";\n    const definitions = [];\n    const orderedExportMap = Array.from(this.exportMap).sort((_ref2, _ref3) => {\n      let [a] = _ref2;\n      let [b] = _ref3;\n      return a < b ? -1 : 1;\n    });\n    for (const [key, value] of orderedExportMap) {\n      definitions.push(`\\n/* harmony export */   ${JSON.stringify(key)}: ${runtimeTemplate.returningFunction(value)}`);\n    }\n    const definePart = this.exportMap.size > 0 ? `/* harmony export */ ${RuntimeGlobals.definePropertyGetters}(${this.exportsArgument}, {${definitions.join(\",\")}\\n/* harmony export */ });\\n` : \"\";\n    return `${definePart}${unusedPart}`;\n  }\n}\nmodule.exports = HarmonyExportInitFragment;","map":{"version":3,"names":["InitFragment","require","RuntimeGlobals","first","joinIterableWithComma","iterable","str","item","EMPTY_MAP","Map","EMPTY_SET","Set","HarmonyExportInitFragment","constructor","exportsArgument","exportMap","unusedExports","undefined","STAGE_HARMONY_EXPORTS","mergeAll","fragments","exportMapOwned","unusedExportsOwned","fragment","size","key","value","has","set","add","merge","other","getContent","runtimeTemplate","runtimeRequirements","exports","definePropertyGetters","unusedPart","definitions","orderedExportMap","Array","from","sort","a","b","push","JSON","stringify","returningFunction","definePart","join","module"],"sources":["C:/Users/galia/OneDrive/Escritorio/rent-a-bike-app/node_modules/webpack/lib/dependencies/HarmonyExportInitFragment.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst InitFragment = require(\"../InitFragment\");\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst { first } = require(\"../util/SetHelpers\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Generator\").GenerateContext} GenerateContext */\n\nconst joinIterableWithComma = iterable => {\n\t// This is more performant than Array.from().join(\", \")\n\t// as it doesn't create an array\n\tlet str = \"\";\n\tlet first = true;\n\tfor (const item of iterable) {\n\t\tif (first) {\n\t\t\tfirst = false;\n\t\t} else {\n\t\t\tstr += \", \";\n\t\t}\n\t\tstr += item;\n\t}\n\treturn str;\n};\n\nconst EMPTY_MAP = new Map();\nconst EMPTY_SET = new Set();\n\n/**\n * @typedef {GenerateContext} Context\n */\nclass HarmonyExportInitFragment extends InitFragment {\n\t/**\n\t * @param {string} exportsArgument the exports identifier\n\t * @param {Map<string, string>} exportMap mapping from used name to exposed variable name\n\t * @param {Set<string>} unusedExports list of unused export names\n\t */\n\tconstructor(\n\t\texportsArgument,\n\t\texportMap = EMPTY_MAP,\n\t\tunusedExports = EMPTY_SET\n\t) {\n\t\tsuper(undefined, InitFragment.STAGE_HARMONY_EXPORTS, 1, \"harmony-exports\");\n\t\tthis.exportsArgument = exportsArgument;\n\t\tthis.exportMap = exportMap;\n\t\tthis.unusedExports = unusedExports;\n\t}\n\n\t/**\n\t * @param {HarmonyExportInitFragment[]} fragments all fragments to merge\n\t * @returns {HarmonyExportInitFragment} merged fragment\n\t */\n\tmergeAll(fragments) {\n\t\tlet exportMap;\n\t\tlet exportMapOwned = false;\n\t\tlet unusedExports;\n\t\tlet unusedExportsOwned = false;\n\n\t\tfor (const fragment of fragments) {\n\t\t\tif (fragment.exportMap.size !== 0) {\n\t\t\t\tif (exportMap === undefined) {\n\t\t\t\t\texportMap = fragment.exportMap;\n\t\t\t\t\texportMapOwned = false;\n\t\t\t\t} else {\n\t\t\t\t\tif (!exportMapOwned) {\n\t\t\t\t\t\texportMap = new Map(exportMap);\n\t\t\t\t\t\texportMapOwned = true;\n\t\t\t\t\t}\n\t\t\t\t\tfor (const [key, value] of fragment.exportMap) {\n\t\t\t\t\t\tif (!exportMap.has(key)) exportMap.set(key, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fragment.unusedExports.size !== 0) {\n\t\t\t\tif (unusedExports === undefined) {\n\t\t\t\t\tunusedExports = fragment.unusedExports;\n\t\t\t\t\tunusedExportsOwned = false;\n\t\t\t\t} else {\n\t\t\t\t\tif (!unusedExportsOwned) {\n\t\t\t\t\t\tunusedExports = new Set(unusedExports);\n\t\t\t\t\t\tunusedExportsOwned = true;\n\t\t\t\t\t}\n\t\t\t\t\tfor (const value of fragment.unusedExports) {\n\t\t\t\t\t\tunusedExports.add(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new HarmonyExportInitFragment(\n\t\t\tthis.exportsArgument,\n\t\t\texportMap,\n\t\t\tunusedExports\n\t\t);\n\t}\n\n\tmerge(other) {\n\t\tlet exportMap;\n\t\tif (this.exportMap.size === 0) {\n\t\t\texportMap = other.exportMap;\n\t\t} else if (other.exportMap.size === 0) {\n\t\t\texportMap = this.exportMap;\n\t\t} else {\n\t\t\texportMap = new Map(other.exportMap);\n\t\t\tfor (const [key, value] of this.exportMap) {\n\t\t\t\tif (!exportMap.has(key)) exportMap.set(key, value);\n\t\t\t}\n\t\t}\n\t\tlet unusedExports;\n\t\tif (this.unusedExports.size === 0) {\n\t\t\tunusedExports = other.unusedExports;\n\t\t} else if (other.unusedExports.size === 0) {\n\t\t\tunusedExports = this.unusedExports;\n\t\t} else {\n\t\t\tunusedExports = new Set(other.unusedExports);\n\t\t\tfor (const value of this.unusedExports) {\n\t\t\t\tunusedExports.add(value);\n\t\t\t}\n\t\t}\n\t\treturn new HarmonyExportInitFragment(\n\t\t\tthis.exportsArgument,\n\t\t\texportMap,\n\t\t\tunusedExports\n\t\t);\n\t}\n\n\t/**\n\t * @param {Context} context context\n\t * @returns {string|Source} the source code that will be included as initialization code\n\t */\n\tgetContent({ runtimeTemplate, runtimeRequirements }) {\n\t\truntimeRequirements.add(RuntimeGlobals.exports);\n\t\truntimeRequirements.add(RuntimeGlobals.definePropertyGetters);\n\n\t\tconst unusedPart =\n\t\t\tthis.unusedExports.size > 1\n\t\t\t\t? `/* unused harmony exports ${joinIterableWithComma(\n\t\t\t\t\t\tthis.unusedExports\n\t\t\t\t  )} */\\n`\n\t\t\t\t: this.unusedExports.size > 0\n\t\t\t\t? `/* unused harmony export ${first(this.unusedExports)} */\\n`\n\t\t\t\t: \"\";\n\t\tconst definitions = [];\n\t\tconst orderedExportMap = Array.from(this.exportMap).sort(([a], [b]) =>\n\t\t\ta < b ? -1 : 1\n\t\t);\n\t\tfor (const [key, value] of orderedExportMap) {\n\t\t\tdefinitions.push(\n\t\t\t\t`\\n/* harmony export */   ${JSON.stringify(\n\t\t\t\t\tkey\n\t\t\t\t)}: ${runtimeTemplate.returningFunction(value)}`\n\t\t\t);\n\t\t}\n\t\tconst definePart =\n\t\t\tthis.exportMap.size > 0\n\t\t\t\t? `/* harmony export */ ${RuntimeGlobals.definePropertyGetters}(${\n\t\t\t\t\t\tthis.exportsArgument\n\t\t\t\t  }, {${definitions.join(\",\")}\\n/* harmony export */ });\\n`\n\t\t\t\t: \"\";\n\t\treturn `${definePart}${unusedPart}`;\n\t}\n}\n\nmodule.exports = HarmonyExportInitFragment;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}