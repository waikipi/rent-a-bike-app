{"ast":null,"code":"'use strict';\n\nconst makeRequest = require('./makeRequest');\nconst utils = require('./utils');\nfunction makeAutoPaginationMethods(self, requestArgs, spec, firstPagePromise) {\n  const promiseCache = {\n    currentPromise: null\n  };\n  const reverseIteration = isReverseIteration(requestArgs);\n  let pagePromise = firstPagePromise;\n  let i = 0;\n  // Search and List methods iterate differently.\n  // Search relies on a `next_page` token and can only iterate in one direction.\n  // List relies on either an `ending_before` or `starting_after` field with\n  // an item ID to paginate and is bi-directional.\n  //\n  // Please note: spec.methodType === 'search' is beta functionality and is\n  // subject to change/removal at any time.\n  let getNextPagePromise;\n  if (spec.methodType === 'search') {\n    getNextPagePromise = pageResult => {\n      if (!pageResult.next_page) {\n        throw Error('Unexpected: Stripe API response does not have a well-formed `next_page` field, but `has_more` was true.');\n      }\n      return makeRequest(self, requestArgs, spec, {\n        page: pageResult.next_page\n      });\n    };\n  } else {\n    getNextPagePromise = pageResult => {\n      const lastId = getLastId(pageResult, reverseIteration);\n      return makeRequest(self, requestArgs, spec, {\n        [reverseIteration ? 'ending_before' : 'starting_after']: lastId\n      });\n    };\n  }\n  function iterate(pageResult) {\n    if (!(pageResult && pageResult.data && typeof pageResult.data.length === 'number')) {\n      throw Error('Unexpected: Stripe API response does not have a well-formed `data` array.');\n    }\n    if (i < pageResult.data.length) {\n      const idx = reverseIteration ? pageResult.data.length - 1 - i : i;\n      const value = pageResult.data[idx];\n      i += 1;\n      return {\n        value,\n        done: false\n      };\n    } else if (pageResult.has_more) {\n      // Reset counter, request next page, and recurse.\n      i = 0;\n      pagePromise = getNextPagePromise(pageResult);\n      return pagePromise.then(iterate);\n    }\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n  function asyncIteratorNext() {\n    return memoizedPromise(promiseCache, (resolve, reject) => {\n      return pagePromise.then(iterate).then(resolve).catch(reject);\n    });\n  }\n  const autoPagingEach = makeAutoPagingEach(asyncIteratorNext);\n  const autoPagingToArray = makeAutoPagingToArray(autoPagingEach);\n  const autoPaginationMethods = {\n    autoPagingEach,\n    autoPagingToArray,\n    // Async iterator functions:\n    next: asyncIteratorNext,\n    return: () => {\n      // This is required for `break`.\n      return {};\n    },\n    [getAsyncIteratorSymbol()]: () => {\n      return autoPaginationMethods;\n    }\n  };\n  return autoPaginationMethods;\n}\n/**\n * ----------------\n * Private Helpers:\n * ----------------\n */\nfunction getAsyncIteratorSymbol() {\n  if (typeof Symbol !== 'undefined' && Symbol.asyncIterator) {\n    return Symbol.asyncIterator;\n  }\n  // Follow the convention from libraries like iterall: https://github.com/leebyron/iterall#asynciterator-1\n  return '@@asyncIterator';\n}\nfunction getDoneCallback(args) {\n  if (args.length < 2) {\n    return undefined;\n  }\n  const onDone = args[1];\n  if (typeof onDone !== 'function') {\n    throw Error(`The second argument to autoPagingEach, if present, must be a callback function; received ${typeof onDone}`);\n  }\n  return onDone;\n}\n/**\n * We allow four forms of the `onItem` callback (the middle two being equivalent),\n *\n *   1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n *   2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n *   3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n *   4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n *\n * In addition to standard validation, this helper\n * coalesces the former forms into the latter form.\n */\nfunction getItemCallback(args) {\n  if (args.length === 0) {\n    return undefined;\n  }\n  const onItem = args[0];\n  if (typeof onItem !== 'function') {\n    throw Error(`The first argument to autoPagingEach, if present, must be a callback function; received ${typeof onItem}`);\n  }\n  // 4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n  if (onItem.length === 2) {\n    return onItem;\n  }\n  if (onItem.length > 2) {\n    throw Error(`The \\`onItem\\` callback function passed to autoPagingEach must accept at most two arguments; got ${onItem}`);\n  }\n  // This magically handles all three of these usecases (the latter two being functionally identical):\n  // 1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n  // 2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n  // 3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n  return function _onItem(item, next) {\n    const shouldContinue = onItem(item);\n    next(shouldContinue);\n  };\n}\nfunction getLastId(listResult, reverseIteration) {\n  const lastIdx = reverseIteration ? 0 : listResult.data.length - 1;\n  const lastItem = listResult.data[lastIdx];\n  const lastId = lastItem && lastItem.id;\n  if (!lastId) {\n    throw Error('Unexpected: No `id` found on the last item while auto-paging a list.');\n  }\n  return lastId;\n}\n/**\n * If a user calls `.next()` multiple times in parallel,\n * return the same result until something has resolved\n * to prevent page-turning race conditions.\n */\nfunction memoizedPromise(promiseCache, cb) {\n  if (promiseCache.currentPromise) {\n    return promiseCache.currentPromise;\n  }\n  promiseCache.currentPromise = new Promise(cb).then(ret => {\n    promiseCache.currentPromise = undefined;\n    return ret;\n  });\n  return promiseCache.currentPromise;\n}\nfunction makeAutoPagingEach(asyncIteratorNext) {\n  return function autoPagingEach( /* onItem?, onDone? */\n  ) {\n    const args = [].slice.call(arguments);\n    const onItem = getItemCallback(args);\n    const onDone = getDoneCallback(args);\n    if (args.length > 2) {\n      throw Error(`autoPagingEach takes up to two arguments; received ${args}`);\n    }\n    const autoPagePromise = wrapAsyncIteratorWithCallback(asyncIteratorNext,\n    // @ts-ignore we might need a null check\n    onItem);\n    return utils.callbackifyPromiseWithTimeout(autoPagePromise, onDone);\n  };\n}\nfunction makeAutoPagingToArray(autoPagingEach) {\n  return function autoPagingToArray(opts, onDone) {\n    const limit = opts && opts.limit;\n    if (!limit) {\n      throw Error('You must pass a `limit` option to autoPagingToArray, e.g., `autoPagingToArray({limit: 1000});`.');\n    }\n    if (limit > 10000) {\n      throw Error('You cannot specify a limit of more than 10,000 items to fetch in `autoPagingToArray`; use `autoPagingEach` to iterate through longer lists.');\n    }\n    const promise = new Promise((resolve, reject) => {\n      const items = [];\n      autoPagingEach(item => {\n        items.push(item);\n        if (items.length >= limit) {\n          return false;\n        }\n      }).then(() => {\n        resolve(items);\n      }).catch(reject);\n    });\n    return utils.callbackifyPromiseWithTimeout(promise, onDone);\n  };\n}\nfunction wrapAsyncIteratorWithCallback(asyncIteratorNext, onItem) {\n  return new Promise((resolve, reject) => {\n    function handleIteration(iterResult) {\n      if (iterResult.done) {\n        resolve();\n        return;\n      }\n      const item = iterResult.value;\n      return new Promise(next => {\n        // Bit confusing, perhaps; we pass a `resolve` fn\n        // to the user, so they can decide when and if to continue.\n        // They can return false, or a promise which resolves to false, to break.\n        onItem(item, next);\n      }).then(shouldContinue => {\n        if (shouldContinue === false) {\n          return handleIteration({\n            done: true\n          });\n        } else {\n          return asyncIteratorNext().then(handleIteration);\n        }\n      });\n    }\n    asyncIteratorNext().then(handleIteration).catch(reject);\n  });\n}\nfunction isReverseIteration(requestArgs) {\n  const args = [].slice.call(requestArgs);\n  const dataFromArgs = utils.getDataFromArgs(args);\n  return !!dataFromArgs.ending_before;\n}\nmodule.exports = {\n  makeAutoPaginationMethods: makeAutoPaginationMethods\n};","map":{"version":3,"names":["makeRequest","require","utils","makeAutoPaginationMethods","self","requestArgs","spec","firstPagePromise","promiseCache","currentPromise","reverseIteration","isReverseIteration","pagePromise","i","getNextPagePromise","methodType","pageResult","next_page","Error","page","lastId","getLastId","iterate","data","length","idx","value","done","has_more","then","undefined","asyncIteratorNext","memoizedPromise","resolve","reject","catch","autoPagingEach","makeAutoPagingEach","autoPagingToArray","makeAutoPagingToArray","autoPaginationMethods","next","return","getAsyncIteratorSymbol","Symbol","asyncIterator","getDoneCallback","args","onDone","getItemCallback","onItem","_onItem","item","shouldContinue","listResult","lastIdx","lastItem","id","cb","Promise","ret","slice","call","arguments","autoPagePromise","wrapAsyncIteratorWithCallback","callbackifyPromiseWithTimeout","opts","limit","promise","items","push","handleIteration","iterResult","dataFromArgs","getDataFromArgs","ending_before","module","exports"],"sources":["C:/Users/galia/OneDrive/Escritorio/rent-a-bike-app/node_modules/stripe/lib/autoPagination.js"],"sourcesContent":["'use strict';\nconst makeRequest = require('./makeRequest');\nconst utils = require('./utils');\nfunction makeAutoPaginationMethods(self, requestArgs, spec, firstPagePromise) {\n  const promiseCache = {currentPromise: null};\n  const reverseIteration = isReverseIteration(requestArgs);\n  let pagePromise = firstPagePromise;\n  let i = 0;\n  // Search and List methods iterate differently.\n  // Search relies on a `next_page` token and can only iterate in one direction.\n  // List relies on either an `ending_before` or `starting_after` field with\n  // an item ID to paginate and is bi-directional.\n  //\n  // Please note: spec.methodType === 'search' is beta functionality and is\n  // subject to change/removal at any time.\n  let getNextPagePromise;\n  if (spec.methodType === 'search') {\n    getNextPagePromise = (pageResult) => {\n      if (!pageResult.next_page) {\n        throw Error(\n          'Unexpected: Stripe API response does not have a well-formed `next_page` field, but `has_more` was true.'\n        );\n      }\n      return makeRequest(self, requestArgs, spec, {\n        page: pageResult.next_page,\n      });\n    };\n  } else {\n    getNextPagePromise = (pageResult) => {\n      const lastId = getLastId(pageResult, reverseIteration);\n      return makeRequest(self, requestArgs, spec, {\n        [reverseIteration ? 'ending_before' : 'starting_after']: lastId,\n      });\n    };\n  }\n  function iterate(pageResult) {\n    if (\n      !(\n        pageResult &&\n        pageResult.data &&\n        typeof pageResult.data.length === 'number'\n      )\n    ) {\n      throw Error(\n        'Unexpected: Stripe API response does not have a well-formed `data` array.'\n      );\n    }\n    if (i < pageResult.data.length) {\n      const idx = reverseIteration ? pageResult.data.length - 1 - i : i;\n      const value = pageResult.data[idx];\n      i += 1;\n      return {value, done: false};\n    } else if (pageResult.has_more) {\n      // Reset counter, request next page, and recurse.\n      i = 0;\n      pagePromise = getNextPagePromise(pageResult);\n      return pagePromise.then(iterate);\n    }\n    return {value: undefined, done: true};\n  }\n  function asyncIteratorNext() {\n    return memoizedPromise(promiseCache, (resolve, reject) => {\n      return pagePromise\n        .then(iterate)\n        .then(resolve)\n        .catch(reject);\n    });\n  }\n  const autoPagingEach = makeAutoPagingEach(asyncIteratorNext);\n  const autoPagingToArray = makeAutoPagingToArray(autoPagingEach);\n  const autoPaginationMethods = {\n    autoPagingEach,\n    autoPagingToArray,\n    // Async iterator functions:\n    next: asyncIteratorNext,\n    return: () => {\n      // This is required for `break`.\n      return {};\n    },\n    [getAsyncIteratorSymbol()]: () => {\n      return autoPaginationMethods;\n    },\n  };\n  return autoPaginationMethods;\n}\n/**\n * ----------------\n * Private Helpers:\n * ----------------\n */\nfunction getAsyncIteratorSymbol() {\n  if (typeof Symbol !== 'undefined' && Symbol.asyncIterator) {\n    return Symbol.asyncIterator;\n  }\n  // Follow the convention from libraries like iterall: https://github.com/leebyron/iterall#asynciterator-1\n  return '@@asyncIterator';\n}\nfunction getDoneCallback(args) {\n  if (args.length < 2) {\n    return undefined;\n  }\n  const onDone = args[1];\n  if (typeof onDone !== 'function') {\n    throw Error(\n      `The second argument to autoPagingEach, if present, must be a callback function; received ${typeof onDone}`\n    );\n  }\n  return onDone;\n}\n/**\n * We allow four forms of the `onItem` callback (the middle two being equivalent),\n *\n *   1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n *   2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n *   3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n *   4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n *\n * In addition to standard validation, this helper\n * coalesces the former forms into the latter form.\n */\nfunction getItemCallback(args) {\n  if (args.length === 0) {\n    return undefined;\n  }\n  const onItem = args[0];\n  if (typeof onItem !== 'function') {\n    throw Error(\n      `The first argument to autoPagingEach, if present, must be a callback function; received ${typeof onItem}`\n    );\n  }\n  // 4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n  if (onItem.length === 2) {\n    return onItem;\n  }\n  if (onItem.length > 2) {\n    throw Error(\n      `The \\`onItem\\` callback function passed to autoPagingEach must accept at most two arguments; got ${onItem}`\n    );\n  }\n  // This magically handles all three of these usecases (the latter two being functionally identical):\n  // 1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n  // 2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n  // 3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n  return function _onItem(item, next) {\n    const shouldContinue = onItem(item);\n    next(shouldContinue);\n  };\n}\nfunction getLastId(listResult, reverseIteration) {\n  const lastIdx = reverseIteration ? 0 : listResult.data.length - 1;\n  const lastItem = listResult.data[lastIdx];\n  const lastId = lastItem && lastItem.id;\n  if (!lastId) {\n    throw Error(\n      'Unexpected: No `id` found on the last item while auto-paging a list.'\n    );\n  }\n  return lastId;\n}\n/**\n * If a user calls `.next()` multiple times in parallel,\n * return the same result until something has resolved\n * to prevent page-turning race conditions.\n */\nfunction memoizedPromise(promiseCache, cb) {\n  if (promiseCache.currentPromise) {\n    return promiseCache.currentPromise;\n  }\n  promiseCache.currentPromise = new Promise(cb).then((ret) => {\n    promiseCache.currentPromise = undefined;\n    return ret;\n  });\n  return promiseCache.currentPromise;\n}\nfunction makeAutoPagingEach(asyncIteratorNext) {\n  return function autoPagingEach(/* onItem?, onDone? */) {\n    const args = [].slice.call(arguments);\n    const onItem = getItemCallback(args);\n    const onDone = getDoneCallback(args);\n    if (args.length > 2) {\n      throw Error(`autoPagingEach takes up to two arguments; received ${args}`);\n    }\n    const autoPagePromise = wrapAsyncIteratorWithCallback(\n      asyncIteratorNext,\n      // @ts-ignore we might need a null check\n      onItem\n    );\n    return utils.callbackifyPromiseWithTimeout(autoPagePromise, onDone);\n  };\n}\nfunction makeAutoPagingToArray(autoPagingEach) {\n  return function autoPagingToArray(opts, onDone) {\n    const limit = opts && opts.limit;\n    if (!limit) {\n      throw Error(\n        'You must pass a `limit` option to autoPagingToArray, e.g., `autoPagingToArray({limit: 1000});`.'\n      );\n    }\n    if (limit > 10000) {\n      throw Error(\n        'You cannot specify a limit of more than 10,000 items to fetch in `autoPagingToArray`; use `autoPagingEach` to iterate through longer lists.'\n      );\n    }\n    const promise = new Promise((resolve, reject) => {\n      const items = [];\n      autoPagingEach((item) => {\n        items.push(item);\n        if (items.length >= limit) {\n          return false;\n        }\n      })\n        .then(() => {\n          resolve(items);\n        })\n        .catch(reject);\n    });\n    return utils.callbackifyPromiseWithTimeout(promise, onDone);\n  };\n}\nfunction wrapAsyncIteratorWithCallback(asyncIteratorNext, onItem) {\n  return new Promise((resolve, reject) => {\n    function handleIteration(iterResult) {\n      if (iterResult.done) {\n        resolve();\n        return;\n      }\n      const item = iterResult.value;\n      return new Promise((next) => {\n        // Bit confusing, perhaps; we pass a `resolve` fn\n        // to the user, so they can decide when and if to continue.\n        // They can return false, or a promise which resolves to false, to break.\n        onItem(item, next);\n      }).then((shouldContinue) => {\n        if (shouldContinue === false) {\n          return handleIteration({done: true});\n        } else {\n          return asyncIteratorNext().then(handleIteration);\n        }\n      });\n    }\n    asyncIteratorNext()\n      .then(handleIteration)\n      .catch(reject);\n  });\n}\nfunction isReverseIteration(requestArgs) {\n  const args = [].slice.call(requestArgs);\n  const dataFromArgs = utils.getDataFromArgs(args);\n  return !!dataFromArgs.ending_before;\n}\nmodule.exports = {\n  makeAutoPaginationMethods: makeAutoPaginationMethods,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}