{"ast":null,"code":"'use strict';\n\nconst utils = require('./utils');\nconst _Error = require('./Error');\nconst {\n  StripeError,\n  StripeSignatureVerificationError\n} = _Error;\nconst Webhook = {\n  DEFAULT_TOLERANCE: 300,\n  // @ts-ignore\n  signature: null,\n  constructEvent(payload, header, secret, tolerance, cryptoProvider) {\n    this.signature.verifyHeader(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE, cryptoProvider);\n    // @ts-ignore\n    const jsonPayload = JSON.parse(payload);\n    return jsonPayload;\n  },\n  async constructEventAsync(payload, header, secret, tolerance, cryptoProvider) {\n    await this.signature.verifyHeaderAsync(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE, cryptoProvider);\n    // @ts-ignore\n    const jsonPayload = JSON.parse(payload);\n    return jsonPayload;\n  },\n  /**\n   * Generates a header to be used for webhook mocking\n   *\n   * @typedef {object} opts\n   * @property {number} timestamp - Timestamp of the header. Defaults to Date.now()\n   * @property {string} payload - JSON stringified payload object, containing the 'id' and 'object' parameters\n   * @property {string} secret - Stripe webhook secret 'whsec_...'\n   * @property {string} scheme - Version of API to hit. Defaults to 'v1'.\n   * @property {string} signature - Computed webhook signature\n   * @property {CryptoProvider} cryptoProvider - Crypto provider to use for computing the signature if none was provided. Defaults to NodeCryptoProvider.\n   */\n  generateTestHeaderString: function (opts) {\n    if (!opts) {\n      throw new StripeError({\n        message: 'Options are required'\n      });\n    }\n    opts.timestamp = Math.floor(opts.timestamp) || Math.floor(Date.now() / 1000);\n    opts.scheme = opts.scheme || signature.EXPECTED_SCHEME;\n    opts.cryptoProvider = opts.cryptoProvider || getNodeCryptoProvider();\n    opts.signature = opts.signature || opts.cryptoProvider.computeHMACSignature(opts.timestamp + '.' + opts.payload, opts.secret);\n    const generatedHeader = ['t=' + opts.timestamp, opts.scheme + '=' + opts.signature].join(',');\n    return generatedHeader;\n  }\n};\nconst signature = {\n  EXPECTED_SCHEME: 'v1',\n  verifyHeader(encodedPayload, encodedHeader, secret, tolerance, cryptoProvider) {\n    const {\n      decodedHeader: header,\n      decodedPayload: payload,\n      details\n    } = parseEventDetails(encodedPayload, encodedHeader, this.EXPECTED_SCHEME);\n    cryptoProvider = cryptoProvider || getNodeCryptoProvider();\n    const expectedSignature = cryptoProvider.computeHMACSignature(makeHMACContent(payload, details), secret);\n    validateComputedSignature(payload, header, details, expectedSignature, tolerance);\n    return true;\n  },\n  async verifyHeaderAsync(encodedPayload, encodedHeader, secret, tolerance, cryptoProvider) {\n    const {\n      decodedHeader: header,\n      decodedPayload: payload,\n      details\n    } = parseEventDetails(encodedPayload, encodedHeader, this.EXPECTED_SCHEME);\n    cryptoProvider = cryptoProvider || getNodeCryptoProvider();\n    const expectedSignature = await cryptoProvider.computeHMACSignatureAsync(makeHMACContent(payload, details), secret);\n    return validateComputedSignature(payload, header, details, expectedSignature, tolerance);\n  }\n};\nfunction makeHMACContent(payload, details) {\n  return `${details.timestamp}.${payload}`;\n}\nfunction parseEventDetails(encodedPayload, encodedHeader, expectedScheme) {\n  const decodedPayload = Buffer.isBuffer(encodedPayload) ? encodedPayload.toString('utf8') : encodedPayload;\n  // Express's type for `Request#headers` is `string | []string`\n  // which is because the `set-cookie` header is an array,\n  // but no other headers are an array (docs: https://nodejs.org/api/http.html#http_message_headers)\n  // (Express's Request class is an extension of http.IncomingMessage, and doesn't appear to be relevantly modified: https://github.com/expressjs/express/blob/master/lib/request.js#L31)\n  if (Array.isArray(encodedHeader)) {\n    throw new Error('Unexpected: An array was passed as a header, which should not be possible for the stripe-signature header.');\n  }\n  const decodedHeader = Buffer.isBuffer(encodedHeader) ? encodedHeader.toString('utf8') : encodedHeader;\n  const details = parseHeader(decodedHeader, expectedScheme);\n  if (!details || details.timestamp === -1) {\n    throw new StripeSignatureVerificationError(decodedHeader, decodedPayload, {\n      message: 'Unable to extract timestamp and signatures from header'\n    });\n  }\n  if (!details.signatures.length) {\n    throw new StripeSignatureVerificationError(decodedHeader, decodedPayload, {\n      message: 'No signatures found with expected scheme'\n    });\n  }\n  return {\n    decodedPayload,\n    decodedHeader,\n    details\n  };\n}\nfunction validateComputedSignature(payload, header, details, expectedSignature, tolerance) {\n  const signatureFound = !!details.signatures.filter(\n  // @ts-ignore\n  utils.secureCompare.bind(utils, expectedSignature)).length;\n  if (!signatureFound) {\n    // @ts-ignore\n    throw new StripeSignatureVerificationError(header, payload, {\n      message: 'No signatures found matching the expected signature for payload.' + ' Are you passing the raw request body you received from Stripe?' + ' https://github.com/stripe/stripe-node#webhook-signing'\n    });\n  }\n  const timestampAge = Math.floor(Date.now() / 1000) - details.timestamp;\n  if (tolerance > 0 && timestampAge > tolerance) {\n    // @ts-ignore\n    throw new StripeSignatureVerificationError(header, payload, {\n      message: 'Timestamp outside the tolerance zone'\n    });\n  }\n  return true;\n}\nfunction parseHeader(header, scheme) {\n  if (typeof header !== 'string') {\n    return null;\n  }\n  return header.split(',').reduce((accum, item) => {\n    const kv = item.split('=');\n    if (kv[0] === 't') {\n      accum.timestamp = parseInt(kv[1], 10);\n    }\n    if (kv[0] === scheme) {\n      accum.signatures.push(kv[1]);\n    }\n    return accum;\n  }, {\n    timestamp: -1,\n    signatures: []\n  });\n}\nlet webhooksNodeCryptoProviderInstance = null;\n/**\n * Lazily instantiate a NodeCryptoProvider instance. This is a stateless object\n * so a singleton can be used here.\n */\nfunction getNodeCryptoProvider() {\n  if (!webhooksNodeCryptoProviderInstance) {\n    const NodeCryptoProvider = require('./crypto/NodeCryptoProvider');\n    webhooksNodeCryptoProviderInstance = new NodeCryptoProvider();\n  }\n  return webhooksNodeCryptoProviderInstance;\n}\nWebhook.signature = signature;\nmodule.exports = Webhook;","map":{"version":3,"names":["utils","require","_Error","StripeError","StripeSignatureVerificationError","Webhook","DEFAULT_TOLERANCE","signature","constructEvent","payload","header","secret","tolerance","cryptoProvider","verifyHeader","jsonPayload","JSON","parse","constructEventAsync","verifyHeaderAsync","generateTestHeaderString","opts","message","timestamp","Math","floor","Date","now","scheme","EXPECTED_SCHEME","getNodeCryptoProvider","computeHMACSignature","generatedHeader","join","encodedPayload","encodedHeader","decodedHeader","decodedPayload","details","parseEventDetails","expectedSignature","makeHMACContent","validateComputedSignature","computeHMACSignatureAsync","expectedScheme","Buffer","isBuffer","toString","Array","isArray","Error","parseHeader","signatures","length","signatureFound","filter","secureCompare","bind","timestampAge","split","reduce","accum","item","kv","parseInt","push","webhooksNodeCryptoProviderInstance","NodeCryptoProvider","module","exports"],"sources":["C:/Users/galia/OneDrive/Escritorio/rent-a-bike-app/node_modules/stripe/lib/Webhooks.js"],"sourcesContent":["'use strict';\nconst utils = require('./utils');\nconst _Error = require('./Error');\nconst {StripeError, StripeSignatureVerificationError} = _Error;\nconst Webhook = {\n  DEFAULT_TOLERANCE: 300,\n  // @ts-ignore\n  signature: null,\n  constructEvent(payload, header, secret, tolerance, cryptoProvider) {\n    this.signature.verifyHeader(\n      payload,\n      header,\n      secret,\n      tolerance || Webhook.DEFAULT_TOLERANCE,\n      cryptoProvider\n    );\n    // @ts-ignore\n    const jsonPayload = JSON.parse(payload);\n    return jsonPayload;\n  },\n  async constructEventAsync(\n    payload,\n    header,\n    secret,\n    tolerance,\n    cryptoProvider\n  ) {\n    await this.signature.verifyHeaderAsync(\n      payload,\n      header,\n      secret,\n      tolerance || Webhook.DEFAULT_TOLERANCE,\n      cryptoProvider\n    );\n    // @ts-ignore\n    const jsonPayload = JSON.parse(payload);\n    return jsonPayload;\n  },\n  /**\n   * Generates a header to be used for webhook mocking\n   *\n   * @typedef {object} opts\n   * @property {number} timestamp - Timestamp of the header. Defaults to Date.now()\n   * @property {string} payload - JSON stringified payload object, containing the 'id' and 'object' parameters\n   * @property {string} secret - Stripe webhook secret 'whsec_...'\n   * @property {string} scheme - Version of API to hit. Defaults to 'v1'.\n   * @property {string} signature - Computed webhook signature\n   * @property {CryptoProvider} cryptoProvider - Crypto provider to use for computing the signature if none was provided. Defaults to NodeCryptoProvider.\n   */\n  generateTestHeaderString: function(opts) {\n    if (!opts) {\n      throw new StripeError({\n        message: 'Options are required',\n      });\n    }\n    opts.timestamp =\n      Math.floor(opts.timestamp) || Math.floor(Date.now() / 1000);\n    opts.scheme = opts.scheme || signature.EXPECTED_SCHEME;\n    opts.cryptoProvider = opts.cryptoProvider || getNodeCryptoProvider();\n    opts.signature =\n      opts.signature ||\n      opts.cryptoProvider.computeHMACSignature(\n        opts.timestamp + '.' + opts.payload,\n        opts.secret\n      );\n    const generatedHeader = [\n      't=' + opts.timestamp,\n      opts.scheme + '=' + opts.signature,\n    ].join(',');\n    return generatedHeader;\n  },\n};\nconst signature = {\n  EXPECTED_SCHEME: 'v1',\n  verifyHeader(\n    encodedPayload,\n    encodedHeader,\n    secret,\n    tolerance,\n    cryptoProvider\n  ) {\n    const {\n      decodedHeader: header,\n      decodedPayload: payload,\n      details,\n    } = parseEventDetails(encodedPayload, encodedHeader, this.EXPECTED_SCHEME);\n    cryptoProvider = cryptoProvider || getNodeCryptoProvider();\n    const expectedSignature = cryptoProvider.computeHMACSignature(\n      makeHMACContent(payload, details),\n      secret\n    );\n    validateComputedSignature(\n      payload,\n      header,\n      details,\n      expectedSignature,\n      tolerance\n    );\n    return true;\n  },\n  async verifyHeaderAsync(\n    encodedPayload,\n    encodedHeader,\n    secret,\n    tolerance,\n    cryptoProvider\n  ) {\n    const {\n      decodedHeader: header,\n      decodedPayload: payload,\n      details,\n    } = parseEventDetails(encodedPayload, encodedHeader, this.EXPECTED_SCHEME);\n    cryptoProvider = cryptoProvider || getNodeCryptoProvider();\n    const expectedSignature = await cryptoProvider.computeHMACSignatureAsync(\n      makeHMACContent(payload, details),\n      secret\n    );\n    return validateComputedSignature(\n      payload,\n      header,\n      details,\n      expectedSignature,\n      tolerance\n    );\n  },\n};\nfunction makeHMACContent(payload, details) {\n  return `${details.timestamp}.${payload}`;\n}\nfunction parseEventDetails(encodedPayload, encodedHeader, expectedScheme) {\n  const decodedPayload = Buffer.isBuffer(encodedPayload)\n    ? encodedPayload.toString('utf8')\n    : encodedPayload;\n  // Express's type for `Request#headers` is `string | []string`\n  // which is because the `set-cookie` header is an array,\n  // but no other headers are an array (docs: https://nodejs.org/api/http.html#http_message_headers)\n  // (Express's Request class is an extension of http.IncomingMessage, and doesn't appear to be relevantly modified: https://github.com/expressjs/express/blob/master/lib/request.js#L31)\n  if (Array.isArray(encodedHeader)) {\n    throw new Error(\n      'Unexpected: An array was passed as a header, which should not be possible for the stripe-signature header.'\n    );\n  }\n  const decodedHeader = Buffer.isBuffer(encodedHeader)\n    ? encodedHeader.toString('utf8')\n    : encodedHeader;\n  const details = parseHeader(decodedHeader, expectedScheme);\n  if (!details || details.timestamp === -1) {\n    throw new StripeSignatureVerificationError(decodedHeader, decodedPayload, {\n      message: 'Unable to extract timestamp and signatures from header',\n    });\n  }\n  if (!details.signatures.length) {\n    throw new StripeSignatureVerificationError(decodedHeader, decodedPayload, {\n      message: 'No signatures found with expected scheme',\n    });\n  }\n  return {\n    decodedPayload,\n    decodedHeader,\n    details,\n  };\n}\nfunction validateComputedSignature(\n  payload,\n  header,\n  details,\n  expectedSignature,\n  tolerance\n) {\n  const signatureFound = !!details.signatures.filter(\n    // @ts-ignore\n    utils.secureCompare.bind(utils, expectedSignature)\n  ).length;\n  if (!signatureFound) {\n    // @ts-ignore\n    throw new StripeSignatureVerificationError(header, payload, {\n      message:\n        'No signatures found matching the expected signature for payload.' +\n        ' Are you passing the raw request body you received from Stripe?' +\n        ' https://github.com/stripe/stripe-node#webhook-signing',\n    });\n  }\n  const timestampAge = Math.floor(Date.now() / 1000) - details.timestamp;\n  if (tolerance > 0 && timestampAge > tolerance) {\n    // @ts-ignore\n    throw new StripeSignatureVerificationError(header, payload, {\n      message: 'Timestamp outside the tolerance zone',\n    });\n  }\n  return true;\n}\nfunction parseHeader(header, scheme) {\n  if (typeof header !== 'string') {\n    return null;\n  }\n  return header.split(',').reduce(\n    (accum, item) => {\n      const kv = item.split('=');\n      if (kv[0] === 't') {\n        accum.timestamp = parseInt(kv[1], 10);\n      }\n      if (kv[0] === scheme) {\n        accum.signatures.push(kv[1]);\n      }\n      return accum;\n    },\n    {\n      timestamp: -1,\n      signatures: [],\n    }\n  );\n}\nlet webhooksNodeCryptoProviderInstance = null;\n/**\n * Lazily instantiate a NodeCryptoProvider instance. This is a stateless object\n * so a singleton can be used here.\n */\nfunction getNodeCryptoProvider() {\n  if (!webhooksNodeCryptoProviderInstance) {\n    const NodeCryptoProvider = require('./crypto/NodeCryptoProvider');\n    webhooksNodeCryptoProviderInstance = new NodeCryptoProvider();\n  }\n  return webhooksNodeCryptoProviderInstance;\n}\nWebhook.signature = signature;\nmodule.exports = Webhook;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}