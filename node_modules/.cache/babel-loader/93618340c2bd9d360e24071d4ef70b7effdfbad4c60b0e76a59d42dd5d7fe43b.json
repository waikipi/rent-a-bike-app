{"ast":null,"code":"'use strict';\n\nconst http = require('http');\nconst https = require('https');\nconst _HttpClient = require('./HttpClient');\nconst {\n  HttpClient,\n  HttpClientResponse\n} = _HttpClient;\nconst defaultHttpAgent = new http.Agent({\n  keepAlive: true\n});\nconst defaultHttpsAgent = new https.Agent({\n  keepAlive: true\n});\n/**\n * HTTP client which uses the Node `http` and `https` packages to issue\n * requests.`\n */\nclass NodeHttpClient extends HttpClient {\n  constructor(agent) {\n    super();\n    this._agent = agent;\n  }\n  /** @override. */\n  getClientName() {\n    return 'node';\n  }\n  makeRequest(host, port, path, method, headers, requestData, protocol, timeout) {\n    const isInsecureConnection = protocol === 'http';\n    let agent = this._agent;\n    if (!agent) {\n      agent = isInsecureConnection ? defaultHttpAgent : defaultHttpsAgent;\n    }\n    const requestPromise = new Promise((resolve, reject) => {\n      const req = (isInsecureConnection ? http : https).request({\n        host: host,\n        port: port,\n        path,\n        method,\n        agent,\n        headers,\n        ciphers: 'DEFAULT:!aNULL:!eNULL:!LOW:!EXPORT:!SSLv2:!MD5'\n      });\n      req.setTimeout(timeout, () => {\n        req.destroy(HttpClient.makeTimeoutError());\n      });\n      req.on('response', res => {\n        resolve(new NodeHttpClientResponse(res));\n      });\n      req.on('error', error => {\n        reject(error);\n      });\n      req.once('socket', socket => {\n        if (socket.connecting) {\n          socket.once(isInsecureConnection ? 'connect' : 'secureConnect', () => {\n            // Send payload; we're safe:\n            req.write(requestData);\n            req.end();\n          });\n        } else {\n          // we're already connected\n          req.write(requestData);\n          req.end();\n        }\n      });\n    });\n    return requestPromise;\n  }\n}\nclass NodeHttpClientResponse extends HttpClientResponse {\n  constructor(res) {\n    // @ts-ignore\n    super(res.statusCode, res.headers || {});\n    this._res = res;\n  }\n  getRawResponse() {\n    return this._res;\n  }\n  toStream(streamCompleteCallback) {\n    // The raw response is itself the stream, so we just return that. To be\n    // backwards compatible, we should invoke the streamCompleteCallback only\n    // once the stream has been fully consumed.\n    this._res.once('end', () => streamCompleteCallback());\n    return this._res;\n  }\n  toJSON() {\n    return new Promise((resolve, reject) => {\n      let response = '';\n      this._res.setEncoding('utf8');\n      this._res.on('data', chunk => {\n        response += chunk;\n      });\n      this._res.once('end', () => {\n        try {\n          resolve(JSON.parse(response));\n        } catch (e) {\n          reject(e);\n        }\n      });\n    });\n  }\n}\nmodule.exports = {\n  NodeHttpClient,\n  NodeHttpClientResponse\n};","map":{"version":3,"names":["http","require","https","_HttpClient","HttpClient","HttpClientResponse","defaultHttpAgent","Agent","keepAlive","defaultHttpsAgent","NodeHttpClient","constructor","agent","_agent","getClientName","makeRequest","host","port","path","method","headers","requestData","protocol","timeout","isInsecureConnection","requestPromise","Promise","resolve","reject","req","request","ciphers","setTimeout","destroy","makeTimeoutError","on","res","NodeHttpClientResponse","error","once","socket","connecting","write","end","statusCode","_res","getRawResponse","toStream","streamCompleteCallback","toJSON","response","setEncoding","chunk","JSON","parse","e","module","exports"],"sources":["C:/Users/galia/OneDrive/Escritorio/rent-a-bike-app/node_modules/stripe/lib/net/NodeHttpClient.js"],"sourcesContent":["'use strict';\nconst http = require('http');\nconst https = require('https');\nconst _HttpClient = require('./HttpClient');\nconst {HttpClient, HttpClientResponse} = _HttpClient;\nconst defaultHttpAgent = new http.Agent({keepAlive: true});\nconst defaultHttpsAgent = new https.Agent({keepAlive: true});\n/**\n * HTTP client which uses the Node `http` and `https` packages to issue\n * requests.`\n */\nclass NodeHttpClient extends HttpClient {\n  constructor(agent) {\n    super();\n    this._agent = agent;\n  }\n  /** @override. */\n  getClientName() {\n    return 'node';\n  }\n  makeRequest(\n    host,\n    port,\n    path,\n    method,\n    headers,\n    requestData,\n    protocol,\n    timeout\n  ) {\n    const isInsecureConnection = protocol === 'http';\n    let agent = this._agent;\n    if (!agent) {\n      agent = isInsecureConnection ? defaultHttpAgent : defaultHttpsAgent;\n    }\n    const requestPromise = new Promise((resolve, reject) => {\n      const req = (isInsecureConnection ? http : https).request({\n        host: host,\n        port: port,\n        path,\n        method,\n        agent,\n        headers,\n        ciphers: 'DEFAULT:!aNULL:!eNULL:!LOW:!EXPORT:!SSLv2:!MD5',\n      });\n      req.setTimeout(timeout, () => {\n        req.destroy(HttpClient.makeTimeoutError());\n      });\n      req.on('response', (res) => {\n        resolve(new NodeHttpClientResponse(res));\n      });\n      req.on('error', (error) => {\n        reject(error);\n      });\n      req.once('socket', (socket) => {\n        if (socket.connecting) {\n          socket.once(\n            isInsecureConnection ? 'connect' : 'secureConnect',\n            () => {\n              // Send payload; we're safe:\n              req.write(requestData);\n              req.end();\n            }\n          );\n        } else {\n          // we're already connected\n          req.write(requestData);\n          req.end();\n        }\n      });\n    });\n    return requestPromise;\n  }\n}\nclass NodeHttpClientResponse extends HttpClientResponse {\n  constructor(res) {\n    // @ts-ignore\n    super(res.statusCode, res.headers || {});\n    this._res = res;\n  }\n  getRawResponse() {\n    return this._res;\n  }\n  toStream(streamCompleteCallback) {\n    // The raw response is itself the stream, so we just return that. To be\n    // backwards compatible, we should invoke the streamCompleteCallback only\n    // once the stream has been fully consumed.\n    this._res.once('end', () => streamCompleteCallback());\n    return this._res;\n  }\n  toJSON() {\n    return new Promise((resolve, reject) => {\n      let response = '';\n      this._res.setEncoding('utf8');\n      this._res.on('data', (chunk) => {\n        response += chunk;\n      });\n      this._res.once('end', () => {\n        try {\n          resolve(JSON.parse(response));\n        } catch (e) {\n          reject(e);\n        }\n      });\n    });\n  }\n}\nmodule.exports = {NodeHttpClient, NodeHttpClientResponse};\n"],"mappings":"AAAA,YAAY;;AACZ,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAMC,KAAK,GAAGD,OAAO,CAAC,OAAO,CAAC;AAC9B,MAAME,WAAW,GAAGF,OAAO,CAAC,cAAc,CAAC;AAC3C,MAAM;EAACG,UAAU;EAAEC;AAAkB,CAAC,GAAGF,WAAW;AACpD,MAAMG,gBAAgB,GAAG,IAAIN,IAAI,CAACO,KAAK,CAAC;EAACC,SAAS,EAAE;AAAI,CAAC,CAAC;AAC1D,MAAMC,iBAAiB,GAAG,IAAIP,KAAK,CAACK,KAAK,CAAC;EAACC,SAAS,EAAE;AAAI,CAAC,CAAC;AAC5D;AACA;AACA;AACA;AACA,MAAME,cAAc,SAASN,UAAU,CAAC;EACtCO,WAAW,CAACC,KAAK,EAAE;IACjB,KAAK,EAAE;IACP,IAAI,CAACC,MAAM,GAAGD,KAAK;EACrB;EACA;EACAE,aAAa,GAAG;IACd,OAAO,MAAM;EACf;EACAC,WAAW,CACTC,IAAI,EACJC,IAAI,EACJC,IAAI,EACJC,MAAM,EACNC,OAAO,EACPC,WAAW,EACXC,QAAQ,EACRC,OAAO,EACP;IACA,MAAMC,oBAAoB,GAAGF,QAAQ,KAAK,MAAM;IAChD,IAAIV,KAAK,GAAG,IAAI,CAACC,MAAM;IACvB,IAAI,CAACD,KAAK,EAAE;MACVA,KAAK,GAAGY,oBAAoB,GAAGlB,gBAAgB,GAAGG,iBAAiB;IACrE;IACA,MAAMgB,cAAc,GAAG,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtD,MAAMC,GAAG,GAAG,CAACL,oBAAoB,GAAGxB,IAAI,GAAGE,KAAK,EAAE4B,OAAO,CAAC;QACxDd,IAAI,EAAEA,IAAI;QACVC,IAAI,EAAEA,IAAI;QACVC,IAAI;QACJC,MAAM;QACNP,KAAK;QACLQ,OAAO;QACPW,OAAO,EAAE;MACX,CAAC,CAAC;MACFF,GAAG,CAACG,UAAU,CAACT,OAAO,EAAE,MAAM;QAC5BM,GAAG,CAACI,OAAO,CAAC7B,UAAU,CAAC8B,gBAAgB,EAAE,CAAC;MAC5C,CAAC,CAAC;MACFL,GAAG,CAACM,EAAE,CAAC,UAAU,EAAGC,GAAG,IAAK;QAC1BT,OAAO,CAAC,IAAIU,sBAAsB,CAACD,GAAG,CAAC,CAAC;MAC1C,CAAC,CAAC;MACFP,GAAG,CAACM,EAAE,CAAC,OAAO,EAAGG,KAAK,IAAK;QACzBV,MAAM,CAACU,KAAK,CAAC;MACf,CAAC,CAAC;MACFT,GAAG,CAACU,IAAI,CAAC,QAAQ,EAAGC,MAAM,IAAK;QAC7B,IAAIA,MAAM,CAACC,UAAU,EAAE;UACrBD,MAAM,CAACD,IAAI,CACTf,oBAAoB,GAAG,SAAS,GAAG,eAAe,EAClD,MAAM;YACJ;YACAK,GAAG,CAACa,KAAK,CAACrB,WAAW,CAAC;YACtBQ,GAAG,CAACc,GAAG,EAAE;UACX,CAAC,CACF;QACH,CAAC,MAAM;UACL;UACAd,GAAG,CAACa,KAAK,CAACrB,WAAW,CAAC;UACtBQ,GAAG,CAACc,GAAG,EAAE;QACX;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;IACF,OAAOlB,cAAc;EACvB;AACF;AACA,MAAMY,sBAAsB,SAAShC,kBAAkB,CAAC;EACtDM,WAAW,CAACyB,GAAG,EAAE;IACf;IACA,KAAK,CAACA,GAAG,CAACQ,UAAU,EAAER,GAAG,CAAChB,OAAO,IAAI,CAAC,CAAC,CAAC;IACxC,IAAI,CAACyB,IAAI,GAAGT,GAAG;EACjB;EACAU,cAAc,GAAG;IACf,OAAO,IAAI,CAACD,IAAI;EAClB;EACAE,QAAQ,CAACC,sBAAsB,EAAE;IAC/B;IACA;IACA;IACA,IAAI,CAACH,IAAI,CAACN,IAAI,CAAC,KAAK,EAAE,MAAMS,sBAAsB,EAAE,CAAC;IACrD,OAAO,IAAI,CAACH,IAAI;EAClB;EACAI,MAAM,GAAG;IACP,OAAO,IAAIvB,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,IAAIsB,QAAQ,GAAG,EAAE;MACjB,IAAI,CAACL,IAAI,CAACM,WAAW,CAAC,MAAM,CAAC;MAC7B,IAAI,CAACN,IAAI,CAACV,EAAE,CAAC,MAAM,EAAGiB,KAAK,IAAK;QAC9BF,QAAQ,IAAIE,KAAK;MACnB,CAAC,CAAC;MACF,IAAI,CAACP,IAAI,CAACN,IAAI,CAAC,KAAK,EAAE,MAAM;QAC1B,IAAI;UACFZ,OAAO,CAAC0B,IAAI,CAACC,KAAK,CAACJ,QAAQ,CAAC,CAAC;QAC/B,CAAC,CAAC,OAAOK,CAAC,EAAE;UACV3B,MAAM,CAAC2B,CAAC,CAAC;QACX;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;AACF;AACAC,MAAM,CAACC,OAAO,GAAG;EAAC/C,cAAc;EAAE2B;AAAsB,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}