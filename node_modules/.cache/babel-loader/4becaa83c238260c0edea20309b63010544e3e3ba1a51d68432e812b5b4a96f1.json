{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  ConcatSource\n} = require(\"webpack-sources\");\nconst {\n  UsageState\n} = require(\"../ExportsInfo\");\nconst Template = require(\"../Template\");\nconst propertyAccess = require(\"../util/propertyAccess\");\nconst {\n  getEntryRuntime\n} = require(\"../util/runtime\");\nconst AbstractLibraryPlugin = require(\"./AbstractLibraryPlugin\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../../declarations/WebpackOptions\").LibraryOptions} LibraryOptions */\n/** @typedef {import(\"../../declarations/WebpackOptions\").LibraryType} LibraryType */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compilation\").ChunkHashContext} ChunkHashContext */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../javascript/JavascriptModulesPlugin\").RenderContext} RenderContext */\n/** @typedef {import(\"../javascript/JavascriptModulesPlugin\").StartupRenderContext} StartupRenderContext */\n/** @typedef {import(\"../util/Hash\")} Hash */\n/** @template T @typedef {import(\"./AbstractLibraryPlugin\").LibraryContext<T>} LibraryContext<T> */\n\nconst KEYWORD_REGEX = /^(await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|super|switch|static|this|throw|try|true|typeof|var|void|while|with|yield)$/;\nconst IDENTIFIER_REGEX = /^[\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}]*$/iu;\n\n/**\n * Validates the library name by checking for keywords and valid characters\n * @param {string} name name to be validated\n * @returns {boolean} true, when valid\n */\nconst isNameValid = name => {\n  return !KEYWORD_REGEX.test(name) && IDENTIFIER_REGEX.test(name);\n};\n\n/**\n * @param {string[]} accessor variable plus properties\n * @param {number} existingLength items of accessor that are existing already\n * @param {boolean=} initLast if the last property should also be initialized to an object\n * @returns {string} code to access the accessor while initializing\n */\nconst accessWithInit = function (accessor, existingLength) {\n  let initLast = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // This generates for [a, b, c, d]:\n  // (((a = typeof a === \"undefined\" ? {} : a).b = a.b || {}).c = a.b.c || {}).d\n  const base = accessor[0];\n  if (accessor.length === 1 && !initLast) return base;\n  let current = existingLength > 0 ? base : `(${base} = typeof ${base} === \"undefined\" ? {} : ${base})`;\n\n  // i is the current position in accessor that has been printed\n  let i = 1;\n\n  // all properties printed so far (excluding base)\n  let propsSoFar;\n\n  // if there is existingLength, print all properties until this position as property access\n  if (existingLength > i) {\n    propsSoFar = accessor.slice(1, existingLength);\n    i = existingLength;\n    current += propertyAccess(propsSoFar);\n  } else {\n    propsSoFar = [];\n  }\n\n  // all remaining properties (except the last one when initLast is not set)\n  // should be printed as initializer\n  const initUntil = initLast ? accessor.length : accessor.length - 1;\n  for (; i < initUntil; i++) {\n    const prop = accessor[i];\n    propsSoFar.push(prop);\n    current = `(${current}${propertyAccess([prop])} = ${base}${propertyAccess(propsSoFar)} || {})`;\n  }\n\n  // print the last property as property access if not yet printed\n  if (i < accessor.length) current = `${current}${propertyAccess([accessor[accessor.length - 1]])}`;\n  return current;\n};\n\n/**\n * @typedef {Object} AssignLibraryPluginOptions\n * @property {LibraryType} type\n * @property {string[] | \"global\"} prefix name prefix\n * @property {string | false} declare declare name as variable\n * @property {\"error\"|\"static\"|\"copy\"|\"assign\"} unnamed behavior for unnamed library name\n * @property {\"copy\"|\"assign\"=} named behavior for named library name\n */\n\n/**\n * @typedef {Object} AssignLibraryPluginParsed\n * @property {string | string[]} name\n * @property {string | string[] | undefined} export\n */\n\n/**\n * @typedef {AssignLibraryPluginParsed} T\n * @extends {AbstractLibraryPlugin<AssignLibraryPluginParsed>}\n */\nclass AssignLibraryPlugin extends AbstractLibraryPlugin {\n  /**\n   * @param {AssignLibraryPluginOptions} options the plugin options\n   */\n  constructor(options) {\n    super({\n      pluginName: \"AssignLibraryPlugin\",\n      type: options.type\n    });\n    this.prefix = options.prefix;\n    this.declare = options.declare;\n    this.unnamed = options.unnamed;\n    this.named = options.named || \"assign\";\n  }\n\n  /**\n   * @param {LibraryOptions} library normalized library option\n   * @returns {T | false} preprocess as needed by overriding\n   */\n  parseOptions(library) {\n    const {\n      name\n    } = library;\n    if (this.unnamed === \"error\") {\n      if (typeof name !== \"string\" && !Array.isArray(name)) {\n        throw new Error(`Library name must be a string or string array. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`);\n      }\n    } else {\n      if (name && typeof name !== \"string\" && !Array.isArray(name)) {\n        throw new Error(`Library name must be a string, string array or unset. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`);\n      }\n    }\n    return {\n      name: /** @type {string|string[]=} */name,\n      export: library.export\n    };\n  }\n\n  /**\n   * @param {Module} module the exporting entry module\n   * @param {string} entryName the name of the entrypoint\n   * @param {LibraryContext<T>} libraryContext context\n   * @returns {void}\n   */\n  finishEntryModule(module, entryName, _ref) {\n    let {\n      options,\n      compilation,\n      compilation: {\n        moduleGraph\n      }\n    } = _ref;\n    const runtime = getEntryRuntime(compilation, entryName);\n    if (options.export) {\n      const exportsInfo = moduleGraph.getExportInfo(module, Array.isArray(options.export) ? options.export[0] : options.export);\n      exportsInfo.setUsed(UsageState.Used, runtime);\n      exportsInfo.canMangleUse = false;\n    } else {\n      const exportsInfo = moduleGraph.getExportsInfo(module);\n      exportsInfo.setUsedInUnknownWay(runtime);\n    }\n    moduleGraph.addExtraReason(module, \"used as library export\");\n  }\n  _getPrefix(compilation) {\n    return this.prefix === \"global\" ? [compilation.runtimeTemplate.globalObject] : this.prefix;\n  }\n  _getResolvedFullName(options, chunk, compilation) {\n    const prefix = this._getPrefix(compilation);\n    const fullName = options.name ? prefix.concat(options.name) : prefix;\n    return fullName.map(n => compilation.getPath(n, {\n      chunk\n    }));\n  }\n\n  /**\n   * @param {Source} source source\n   * @param {RenderContext} renderContext render context\n   * @param {LibraryContext<T>} libraryContext context\n   * @returns {Source} source with library export\n   */\n  render(source, _ref2, _ref3) {\n    let {\n      chunk\n    } = _ref2;\n    let {\n      options,\n      compilation\n    } = _ref3;\n    const fullNameResolved = this._getResolvedFullName(options, chunk, compilation);\n    if (this.declare) {\n      const base = fullNameResolved[0];\n      if (!isNameValid(base)) {\n        throw new Error(`Library name base (${base}) must be a valid identifier when using a var declaring library type. Either use a valid identifier (e. g. ${Template.toIdentifier(base)}) or use a different library type (e. g. 'type: \"global\"', which assign a property on the global scope instead of declaring a variable). ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`);\n      }\n      source = new ConcatSource(`${this.declare} ${base};\\n`, source);\n    }\n    return source;\n  }\n\n  /**\n   * @param {Module} module the exporting entry module\n   * @param {RenderContext} renderContext render context\n   * @param {LibraryContext<T>} libraryContext context\n   * @returns {string | undefined} bailout reason\n   */\n  embedInRuntimeBailout(module, _ref4, _ref5) {\n    let {\n      chunk,\n      codeGenerationResults\n    } = _ref4;\n    let {\n      options,\n      compilation\n    } = _ref5;\n    const {\n      data\n    } = codeGenerationResults.get(module, chunk.runtime);\n    const topLevelDeclarations = data && data.get(\"topLevelDeclarations\") || module.buildInfo && module.buildInfo.topLevelDeclarations;\n    if (!topLevelDeclarations) return \"it doesn't tell about top level declarations.\";\n    const fullNameResolved = this._getResolvedFullName(options, chunk, compilation);\n    const base = fullNameResolved[0];\n    if (topLevelDeclarations.has(base)) return `it declares '${base}' on top-level, which conflicts with the current library output.`;\n  }\n\n  /**\n   * @param {RenderContext} renderContext render context\n   * @param {LibraryContext<T>} libraryContext context\n   * @returns {string | undefined} bailout reason\n   */\n  strictRuntimeBailout(_ref6, _ref7) {\n    let {\n      chunk\n    } = _ref6;\n    let {\n      options,\n      compilation\n    } = _ref7;\n    if (this.declare || this.prefix === \"global\" || this.prefix.length > 0 || !options.name) {\n      return;\n    }\n    return \"a global variable is assign and maybe created\";\n  }\n\n  /**\n   * @param {Source} source source\n   * @param {Module} module module\n   * @param {StartupRenderContext} renderContext render context\n   * @param {LibraryContext<T>} libraryContext context\n   * @returns {Source} source with library export\n   */\n  renderStartup(source, module, _ref8, _ref9) {\n    let {\n      moduleGraph,\n      chunk\n    } = _ref8;\n    let {\n      options,\n      compilation\n    } = _ref9;\n    const fullNameResolved = this._getResolvedFullName(options, chunk, compilation);\n    const staticExports = this.unnamed === \"static\";\n    const exportAccess = options.export ? propertyAccess(Array.isArray(options.export) ? options.export : [options.export]) : \"\";\n    const result = new ConcatSource(source);\n    if (staticExports) {\n      const exportsInfo = moduleGraph.getExportsInfo(module);\n      const exportTarget = accessWithInit(fullNameResolved, this._getPrefix(compilation).length, true);\n      for (const exportInfo of exportsInfo.orderedExports) {\n        if (!exportInfo.provided) continue;\n        const nameAccess = propertyAccess([exportInfo.name]);\n        result.add(`${exportTarget}${nameAccess} = __webpack_exports__${exportAccess}${nameAccess};\\n`);\n      }\n      result.add(`Object.defineProperty(${exportTarget}, \"__esModule\", { value: true });\\n`);\n    } else if (options.name ? this.named === \"copy\" : this.unnamed === \"copy\") {\n      result.add(`var __webpack_export_target__ = ${accessWithInit(fullNameResolved, this._getPrefix(compilation).length, true)};\\n`);\n      let exports = \"__webpack_exports__\";\n      if (exportAccess) {\n        result.add(`var __webpack_exports_export__ = __webpack_exports__${exportAccess};\\n`);\n        exports = \"__webpack_exports_export__\";\n      }\n      result.add(`for(var i in ${exports}) __webpack_export_target__[i] = ${exports}[i];\\n`);\n      result.add(`if(${exports}.__esModule) Object.defineProperty(__webpack_export_target__, \"__esModule\", { value: true });\\n`);\n    } else {\n      result.add(`${accessWithInit(fullNameResolved, this._getPrefix(compilation).length, false)} = __webpack_exports__${exportAccess};\\n`);\n    }\n    return result;\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Set<string>} set runtime requirements\n   * @param {LibraryContext<T>} libraryContext context\n   * @returns {void}\n   */\n  runtimeRequirements(chunk, set, libraryContext) {\n    // we don't need to return exports from runtime\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Hash} hash hash\n   * @param {ChunkHashContext} chunkHashContext chunk hash context\n   * @param {LibraryContext<T>} libraryContext context\n   * @returns {void}\n   */\n  chunkHash(chunk, hash, chunkHashContext, _ref10) {\n    let {\n      options,\n      compilation\n    } = _ref10;\n    hash.update(\"AssignLibraryPlugin\");\n    const fullNameResolved = this._getResolvedFullName(options, chunk, compilation);\n    if (options.name ? this.named === \"copy\" : this.unnamed === \"copy\") {\n      hash.update(\"copy\");\n    }\n    if (this.declare) {\n      hash.update(this.declare);\n    }\n    hash.update(fullNameResolved.join(\".\"));\n    if (options.export) {\n      hash.update(`${options.export}`);\n    }\n  }\n}\nmodule.exports = AssignLibraryPlugin;","map":{"version":3,"names":["ConcatSource","require","UsageState","Template","propertyAccess","getEntryRuntime","AbstractLibraryPlugin","KEYWORD_REGEX","IDENTIFIER_REGEX","isNameValid","name","test","accessWithInit","accessor","existingLength","initLast","base","length","current","i","propsSoFar","slice","initUntil","prop","push","AssignLibraryPlugin","constructor","options","pluginName","type","prefix","declare","unnamed","named","parseOptions","library","Array","isArray","Error","COMMON_LIBRARY_NAME_MESSAGE","export","finishEntryModule","module","entryName","compilation","moduleGraph","runtime","exportsInfo","getExportInfo","setUsed","Used","canMangleUse","getExportsInfo","setUsedInUnknownWay","addExtraReason","_getPrefix","runtimeTemplate","globalObject","_getResolvedFullName","chunk","fullName","concat","map","n","getPath","render","source","fullNameResolved","toIdentifier","embedInRuntimeBailout","codeGenerationResults","data","get","topLevelDeclarations","buildInfo","has","strictRuntimeBailout","renderStartup","staticExports","exportAccess","result","exportTarget","exportInfo","orderedExports","provided","nameAccess","add","exports","runtimeRequirements","set","libraryContext","chunkHash","hash","chunkHashContext","update","join"],"sources":["C:/Users/galia/OneDrive/Escritorio/rent-a-bike-app/node_modules/webpack/lib/library/AssignLibraryPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { ConcatSource } = require(\"webpack-sources\");\nconst { UsageState } = require(\"../ExportsInfo\");\nconst Template = require(\"../Template\");\nconst propertyAccess = require(\"../util/propertyAccess\");\nconst { getEntryRuntime } = require(\"../util/runtime\");\nconst AbstractLibraryPlugin = require(\"./AbstractLibraryPlugin\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../../declarations/WebpackOptions\").LibraryOptions} LibraryOptions */\n/** @typedef {import(\"../../declarations/WebpackOptions\").LibraryType} LibraryType */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compilation\").ChunkHashContext} ChunkHashContext */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../javascript/JavascriptModulesPlugin\").RenderContext} RenderContext */\n/** @typedef {import(\"../javascript/JavascriptModulesPlugin\").StartupRenderContext} StartupRenderContext */\n/** @typedef {import(\"../util/Hash\")} Hash */\n/** @template T @typedef {import(\"./AbstractLibraryPlugin\").LibraryContext<T>} LibraryContext<T> */\n\nconst KEYWORD_REGEX =\n\t/^(await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|super|switch|static|this|throw|try|true|typeof|var|void|while|with|yield)$/;\nconst IDENTIFIER_REGEX =\n\t/^[\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}]*$/iu;\n\n/**\n * Validates the library name by checking for keywords and valid characters\n * @param {string} name name to be validated\n * @returns {boolean} true, when valid\n */\nconst isNameValid = name => {\n\treturn !KEYWORD_REGEX.test(name) && IDENTIFIER_REGEX.test(name);\n};\n\n/**\n * @param {string[]} accessor variable plus properties\n * @param {number} existingLength items of accessor that are existing already\n * @param {boolean=} initLast if the last property should also be initialized to an object\n * @returns {string} code to access the accessor while initializing\n */\nconst accessWithInit = (accessor, existingLength, initLast = false) => {\n\t// This generates for [a, b, c, d]:\n\t// (((a = typeof a === \"undefined\" ? {} : a).b = a.b || {}).c = a.b.c || {}).d\n\tconst base = accessor[0];\n\tif (accessor.length === 1 && !initLast) return base;\n\tlet current =\n\t\texistingLength > 0\n\t\t\t? base\n\t\t\t: `(${base} = typeof ${base} === \"undefined\" ? {} : ${base})`;\n\n\t// i is the current position in accessor that has been printed\n\tlet i = 1;\n\n\t// all properties printed so far (excluding base)\n\tlet propsSoFar;\n\n\t// if there is existingLength, print all properties until this position as property access\n\tif (existingLength > i) {\n\t\tpropsSoFar = accessor.slice(1, existingLength);\n\t\ti = existingLength;\n\t\tcurrent += propertyAccess(propsSoFar);\n\t} else {\n\t\tpropsSoFar = [];\n\t}\n\n\t// all remaining properties (except the last one when initLast is not set)\n\t// should be printed as initializer\n\tconst initUntil = initLast ? accessor.length : accessor.length - 1;\n\tfor (; i < initUntil; i++) {\n\t\tconst prop = accessor[i];\n\t\tpropsSoFar.push(prop);\n\t\tcurrent = `(${current}${propertyAccess([prop])} = ${base}${propertyAccess(\n\t\t\tpropsSoFar\n\t\t)} || {})`;\n\t}\n\n\t// print the last property as property access if not yet printed\n\tif (i < accessor.length)\n\t\tcurrent = `${current}${propertyAccess([accessor[accessor.length - 1]])}`;\n\n\treturn current;\n};\n\n/**\n * @typedef {Object} AssignLibraryPluginOptions\n * @property {LibraryType} type\n * @property {string[] | \"global\"} prefix name prefix\n * @property {string | false} declare declare name as variable\n * @property {\"error\"|\"static\"|\"copy\"|\"assign\"} unnamed behavior for unnamed library name\n * @property {\"copy\"|\"assign\"=} named behavior for named library name\n */\n\n/**\n * @typedef {Object} AssignLibraryPluginParsed\n * @property {string | string[]} name\n * @property {string | string[] | undefined} export\n */\n\n/**\n * @typedef {AssignLibraryPluginParsed} T\n * @extends {AbstractLibraryPlugin<AssignLibraryPluginParsed>}\n */\nclass AssignLibraryPlugin extends AbstractLibraryPlugin {\n\t/**\n\t * @param {AssignLibraryPluginOptions} options the plugin options\n\t */\n\tconstructor(options) {\n\t\tsuper({\n\t\t\tpluginName: \"AssignLibraryPlugin\",\n\t\t\ttype: options.type\n\t\t});\n\t\tthis.prefix = options.prefix;\n\t\tthis.declare = options.declare;\n\t\tthis.unnamed = options.unnamed;\n\t\tthis.named = options.named || \"assign\";\n\t}\n\n\t/**\n\t * @param {LibraryOptions} library normalized library option\n\t * @returns {T | false} preprocess as needed by overriding\n\t */\n\tparseOptions(library) {\n\t\tconst { name } = library;\n\t\tif (this.unnamed === \"error\") {\n\t\t\tif (typeof name !== \"string\" && !Array.isArray(name)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Library name must be a string or string array. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tif (name && typeof name !== \"string\" && !Array.isArray(name)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Library name must be a string, string array or unset. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tname: /** @type {string|string[]=} */ (name),\n\t\t\texport: library.export\n\t\t};\n\t}\n\n\t/**\n\t * @param {Module} module the exporting entry module\n\t * @param {string} entryName the name of the entrypoint\n\t * @param {LibraryContext<T>} libraryContext context\n\t * @returns {void}\n\t */\n\tfinishEntryModule(\n\t\tmodule,\n\t\tentryName,\n\t\t{ options, compilation, compilation: { moduleGraph } }\n\t) {\n\t\tconst runtime = getEntryRuntime(compilation, entryName);\n\t\tif (options.export) {\n\t\t\tconst exportsInfo = moduleGraph.getExportInfo(\n\t\t\t\tmodule,\n\t\t\t\tArray.isArray(options.export) ? options.export[0] : options.export\n\t\t\t);\n\t\t\texportsInfo.setUsed(UsageState.Used, runtime);\n\t\t\texportsInfo.canMangleUse = false;\n\t\t} else {\n\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\texportsInfo.setUsedInUnknownWay(runtime);\n\t\t}\n\t\tmoduleGraph.addExtraReason(module, \"used as library export\");\n\t}\n\n\t_getPrefix(compilation) {\n\t\treturn this.prefix === \"global\"\n\t\t\t? [compilation.runtimeTemplate.globalObject]\n\t\t\t: this.prefix;\n\t}\n\n\t_getResolvedFullName(options, chunk, compilation) {\n\t\tconst prefix = this._getPrefix(compilation);\n\t\tconst fullName = options.name ? prefix.concat(options.name) : prefix;\n\t\treturn fullName.map(n =>\n\t\t\tcompilation.getPath(n, {\n\t\t\t\tchunk\n\t\t\t})\n\t\t);\n\t}\n\n\t/**\n\t * @param {Source} source source\n\t * @param {RenderContext} renderContext render context\n\t * @param {LibraryContext<T>} libraryContext context\n\t * @returns {Source} source with library export\n\t */\n\trender(source, { chunk }, { options, compilation }) {\n\t\tconst fullNameResolved = this._getResolvedFullName(\n\t\t\toptions,\n\t\t\tchunk,\n\t\t\tcompilation\n\t\t);\n\t\tif (this.declare) {\n\t\t\tconst base = fullNameResolved[0];\n\t\t\tif (!isNameValid(base)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Library name base (${base}) must be a valid identifier when using a var declaring library type. Either use a valid identifier (e. g. ${Template.toIdentifier(\n\t\t\t\t\t\tbase\n\t\t\t\t\t)}) or use a different library type (e. g. 'type: \"global\"', which assign a property on the global scope instead of declaring a variable). ${\n\t\t\t\t\t\tAbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE\n\t\t\t\t\t}`\n\t\t\t\t);\n\t\t\t}\n\t\t\tsource = new ConcatSource(`${this.declare} ${base};\\n`, source);\n\t\t}\n\t\treturn source;\n\t}\n\n\t/**\n\t * @param {Module} module the exporting entry module\n\t * @param {RenderContext} renderContext render context\n\t * @param {LibraryContext<T>} libraryContext context\n\t * @returns {string | undefined} bailout reason\n\t */\n\tembedInRuntimeBailout(\n\t\tmodule,\n\t\t{ chunk, codeGenerationResults },\n\t\t{ options, compilation }\n\t) {\n\t\tconst { data } = codeGenerationResults.get(module, chunk.runtime);\n\t\tconst topLevelDeclarations =\n\t\t\t(data && data.get(\"topLevelDeclarations\")) ||\n\t\t\t(module.buildInfo && module.buildInfo.topLevelDeclarations);\n\t\tif (!topLevelDeclarations)\n\t\t\treturn \"it doesn't tell about top level declarations.\";\n\t\tconst fullNameResolved = this._getResolvedFullName(\n\t\t\toptions,\n\t\t\tchunk,\n\t\t\tcompilation\n\t\t);\n\t\tconst base = fullNameResolved[0];\n\t\tif (topLevelDeclarations.has(base))\n\t\t\treturn `it declares '${base}' on top-level, which conflicts with the current library output.`;\n\t}\n\n\t/**\n\t * @param {RenderContext} renderContext render context\n\t * @param {LibraryContext<T>} libraryContext context\n\t * @returns {string | undefined} bailout reason\n\t */\n\tstrictRuntimeBailout({ chunk }, { options, compilation }) {\n\t\tif (\n\t\t\tthis.declare ||\n\t\t\tthis.prefix === \"global\" ||\n\t\t\tthis.prefix.length > 0 ||\n\t\t\t!options.name\n\t\t) {\n\t\t\treturn;\n\t\t}\n\t\treturn \"a global variable is assign and maybe created\";\n\t}\n\n\t/**\n\t * @param {Source} source source\n\t * @param {Module} module module\n\t * @param {StartupRenderContext} renderContext render context\n\t * @param {LibraryContext<T>} libraryContext context\n\t * @returns {Source} source with library export\n\t */\n\trenderStartup(\n\t\tsource,\n\t\tmodule,\n\t\t{ moduleGraph, chunk },\n\t\t{ options, compilation }\n\t) {\n\t\tconst fullNameResolved = this._getResolvedFullName(\n\t\t\toptions,\n\t\t\tchunk,\n\t\t\tcompilation\n\t\t);\n\t\tconst staticExports = this.unnamed === \"static\";\n\t\tconst exportAccess = options.export\n\t\t\t? propertyAccess(\n\t\t\t\t\tArray.isArray(options.export) ? options.export : [options.export]\n\t\t\t  )\n\t\t\t: \"\";\n\t\tconst result = new ConcatSource(source);\n\t\tif (staticExports) {\n\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\tconst exportTarget = accessWithInit(\n\t\t\t\tfullNameResolved,\n\t\t\t\tthis._getPrefix(compilation).length,\n\t\t\t\ttrue\n\t\t\t);\n\t\t\tfor (const exportInfo of exportsInfo.orderedExports) {\n\t\t\t\tif (!exportInfo.provided) continue;\n\t\t\t\tconst nameAccess = propertyAccess([exportInfo.name]);\n\t\t\t\tresult.add(\n\t\t\t\t\t`${exportTarget}${nameAccess} = __webpack_exports__${exportAccess}${nameAccess};\\n`\n\t\t\t\t);\n\t\t\t}\n\t\t\tresult.add(\n\t\t\t\t`Object.defineProperty(${exportTarget}, \"__esModule\", { value: true });\\n`\n\t\t\t);\n\t\t} else if (options.name ? this.named === \"copy\" : this.unnamed === \"copy\") {\n\t\t\tresult.add(\n\t\t\t\t`var __webpack_export_target__ = ${accessWithInit(\n\t\t\t\t\tfullNameResolved,\n\t\t\t\t\tthis._getPrefix(compilation).length,\n\t\t\t\t\ttrue\n\t\t\t\t)};\\n`\n\t\t\t);\n\t\t\tlet exports = \"__webpack_exports__\";\n\t\t\tif (exportAccess) {\n\t\t\t\tresult.add(\n\t\t\t\t\t`var __webpack_exports_export__ = __webpack_exports__${exportAccess};\\n`\n\t\t\t\t);\n\t\t\t\texports = \"__webpack_exports_export__\";\n\t\t\t}\n\t\t\tresult.add(\n\t\t\t\t`for(var i in ${exports}) __webpack_export_target__[i] = ${exports}[i];\\n`\n\t\t\t);\n\t\t\tresult.add(\n\t\t\t\t`if(${exports}.__esModule) Object.defineProperty(__webpack_export_target__, \"__esModule\", { value: true });\\n`\n\t\t\t);\n\t\t} else {\n\t\t\tresult.add(\n\t\t\t\t`${accessWithInit(\n\t\t\t\t\tfullNameResolved,\n\t\t\t\t\tthis._getPrefix(compilation).length,\n\t\t\t\t\tfalse\n\t\t\t\t)} = __webpack_exports__${exportAccess};\\n`\n\t\t\t);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Set<string>} set runtime requirements\n\t * @param {LibraryContext<T>} libraryContext context\n\t * @returns {void}\n\t */\n\truntimeRequirements(chunk, set, libraryContext) {\n\t\t// we don't need to return exports from runtime\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Hash} hash hash\n\t * @param {ChunkHashContext} chunkHashContext chunk hash context\n\t * @param {LibraryContext<T>} libraryContext context\n\t * @returns {void}\n\t */\n\tchunkHash(chunk, hash, chunkHashContext, { options, compilation }) {\n\t\thash.update(\"AssignLibraryPlugin\");\n\t\tconst fullNameResolved = this._getResolvedFullName(\n\t\t\toptions,\n\t\t\tchunk,\n\t\t\tcompilation\n\t\t);\n\t\tif (options.name ? this.named === \"copy\" : this.unnamed === \"copy\") {\n\t\t\thash.update(\"copy\");\n\t\t}\n\t\tif (this.declare) {\n\t\t\thash.update(this.declare);\n\t\t}\n\t\thash.update(fullNameResolved.join(\".\"));\n\t\tif (options.export) {\n\t\t\thash.update(`${options.export}`);\n\t\t}\n\t}\n}\n\nmodule.exports = AssignLibraryPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}