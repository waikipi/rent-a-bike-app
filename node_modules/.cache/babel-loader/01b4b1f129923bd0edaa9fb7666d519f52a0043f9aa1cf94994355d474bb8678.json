{"ast":null,"code":"'use strict';\n\nconst utils = require('./utils');\nconst _Error = require('./Error');\nconst {\n  StripeAPIError,\n  StripeAuthenticationError,\n  StripeConnectionError,\n  StripeError,\n  StripePermissionError,\n  StripeRateLimitError\n} = _Error;\nconst {\n  HttpClient\n} = require('./net/HttpClient');\n// Provide extension mechanism for Stripe Resource Sub-Classes\nStripeResource.extend = utils.protoExtend;\n// Expose method-creator\nStripeResource.method = require('./StripeMethod');\nStripeResource.MAX_BUFFERED_REQUEST_METRICS = 100;\nconst MAX_RETRY_AFTER_WAIT = 60;\n/**\n * Encapsulates request logic for a Stripe Resource\n */\nfunction StripeResource(stripe, deprecatedUrlData) {\n  this._stripe = stripe;\n  if (deprecatedUrlData) {\n    throw new Error('Support for curried url params was dropped in stripe-node v7.0.0. Instead, pass two ids.');\n  }\n  this.basePath = utils.makeURLInterpolator(\n  // @ts-ignore changing type of basePath\n  this.basePath || stripe.getApiField('basePath'));\n  // @ts-ignore changing type of path\n  this.resourcePath = this.path;\n  // @ts-ignore changing type of path\n  this.path = utils.makeURLInterpolator(this.path);\n  this.initialize(...arguments);\n}\nStripeResource.prototype = {\n  _stripe: null,\n  // @ts-ignore the type of path changes in ctor\n  path: '',\n  resourcePath: '',\n  // Methods that don't use the API's default '/v1' path can override it with this setting.\n  basePath: null,\n  initialize() {},\n  // Function to override the default data processor. This allows full control\n  // over how a StripeResource's request data will get converted into an HTTP\n  // body. This is useful for non-standard HTTP requests. The function should\n  // take method name, data, and headers as arguments.\n  requestDataProcessor: null,\n  // Function to add a validation checks before sending the request, errors should\n  // be thrown, and they will be passed to the callback/promise.\n  validateRequest: null,\n  createFullPath(commandPath, urlData) {\n    const urlParts = [this.basePath(urlData), this.path(urlData)];\n    if (typeof commandPath === 'function') {\n      const computedCommandPath = commandPath(urlData);\n      // If we have no actual command path, we just omit it to avoid adding a\n      // trailing slash. This is important for top-level listing requests, which\n      // do not have a command path.\n      if (computedCommandPath) {\n        urlParts.push(computedCommandPath);\n      }\n    } else {\n      urlParts.push(commandPath);\n    }\n    return this._joinUrlParts(urlParts);\n  },\n  // Creates a relative resource path with symbols left in (unlike\n  // createFullPath which takes some data to replace them with). For example it\n  // might produce: /invoices/{id}\n  createResourcePathWithSymbols(pathWithSymbols) {\n    // If there is no path beyond the resource path, we want to produce just\n    // /<resource path> rather than /<resource path>/.\n    if (pathWithSymbols) {\n      return `/${this._joinUrlParts([this.resourcePath, pathWithSymbols])}`;\n    } else {\n      return `/${this.resourcePath}`;\n    }\n  },\n  _joinUrlParts(parts) {\n    // Replace any accidentally doubled up slashes. This previously used\n    // path.join, which would do this as well. Unfortunately we need to do this\n    // as the functions for creating paths are technically part of the public\n    // interface and so we need to preserve backwards compatibility.\n    return parts.join('/').replace(/\\/{2,}/g, '/');\n  },\n  _addHeadersDirectlyToObject(obj, headers) {\n    // For convenience, make some headers easily accessible on\n    // lastResponse.\n    // NOTE: Stripe responds with lowercase header names/keys.\n    obj.requestId = headers['request-id'];\n    obj.stripeAccount = obj.stripeAccount || headers['stripe-account'];\n    obj.apiVersion = obj.apiVersion || headers['stripe-version'];\n    obj.idempotencyKey = obj.idempotencyKey || headers['idempotency-key'];\n  },\n  _makeResponseEvent(requestEvent, statusCode, headers) {\n    const requestEndTime = Date.now();\n    const requestDurationMs = requestEndTime - requestEvent.request_start_time;\n    return utils.removeNullish({\n      api_version: headers['stripe-version'],\n      account: headers['stripe-account'],\n      idempotency_key: headers['idempotency-key'],\n      method: requestEvent.method,\n      path: requestEvent.path,\n      status: statusCode,\n      request_id: this._getRequestId(headers),\n      elapsed: requestDurationMs,\n      request_start_time: requestEvent.request_start_time,\n      request_end_time: requestEndTime\n    });\n  },\n  _getRequestId(headers) {\n    return headers['request-id'];\n  },\n  /**\n   * Used by methods with spec.streaming === true. For these methods, we do not\n   * buffer successful responses into memory or do parse them into stripe\n   * objects, we delegate that all of that to the user and pass back the raw\n   * http.Response object to the callback.\n   *\n   * (Unsuccessful responses shouldn't make it here, they should\n   * still be buffered/parsed and handled by _jsonResponseHandler -- see\n   * makeRequest)\n   */\n  _streamingResponseHandler(requestEvent, callback) {\n    return res => {\n      const headers = res.getHeaders();\n      const streamCompleteCallback = () => {\n        const responseEvent = this._makeResponseEvent(requestEvent, res.getStatusCode(), headers);\n        this._stripe._emitter.emit('response', responseEvent);\n        this._recordRequestMetrics(this._getRequestId(headers), responseEvent.elapsed);\n      };\n      const stream = res.toStream(streamCompleteCallback);\n      // This is here for backwards compatibility, as the stream is a raw\n      // HTTP response in Node and the legacy behavior was to mutate this\n      // response.\n      this._addHeadersDirectlyToObject(stream, headers);\n      return callback(null, stream);\n    };\n  },\n  /**\n   * Default handler for Stripe responses. Buffers the response into memory,\n   * parses the JSON and returns it (i.e. passes it to the callback) if there\n   * is no \"error\" field. Otherwise constructs/passes an appropriate Error.\n   */\n  _jsonResponseHandler(requestEvent, callback) {\n    return res => {\n      const headers = res.getHeaders();\n      const requestId = this._getRequestId(headers);\n      const statusCode = res.getStatusCode();\n      const responseEvent = this._makeResponseEvent(requestEvent, statusCode, headers);\n      this._stripe._emitter.emit('response', responseEvent);\n      res.toJSON().then(jsonResponse => {\n        if (jsonResponse.error) {\n          let err;\n          // Convert OAuth error responses into a standard format\n          // so that the rest of the error logic can be shared\n          if (typeof jsonResponse.error === 'string') {\n            jsonResponse.error = {\n              type: jsonResponse.error,\n              message: jsonResponse.error_description\n            };\n          }\n          jsonResponse.error.headers = headers;\n          jsonResponse.error.statusCode = statusCode;\n          jsonResponse.error.requestId = requestId;\n          if (statusCode === 401) {\n            err = new StripeAuthenticationError(jsonResponse.error);\n          } else if (statusCode === 403) {\n            err = new StripePermissionError(jsonResponse.error);\n          } else if (statusCode === 429) {\n            err = new StripeRateLimitError(jsonResponse.error);\n          } else {\n            err = StripeError.generate(jsonResponse.error);\n          }\n          throw err;\n        }\n        return jsonResponse;\n      }, e => {\n        throw new StripeAPIError({\n          message: 'Invalid JSON received from the Stripe API',\n          exception: e,\n          requestId: headers['request-id']\n        });\n      }).then(jsonResponse => {\n        this._recordRequestMetrics(requestId, responseEvent.elapsed);\n        // Expose raw response object.\n        const rawResponse = res.getRawResponse();\n        this._addHeadersDirectlyToObject(rawResponse, headers);\n        Object.defineProperty(jsonResponse, 'lastResponse', {\n          enumerable: false,\n          writable: false,\n          value: rawResponse\n        });\n        callback.call(this, null, jsonResponse);\n      }, e => callback.call(this, e, null));\n    };\n  },\n  _generateConnectionErrorMessage(requestRetries) {\n    return `An error occurred with our connection to Stripe.${requestRetries > 0 ? ` Request was retried ${requestRetries} times.` : ''}`;\n  },\n  // For more on when and how to retry API requests, see https://stripe.com/docs/error-handling#safely-retrying-requests-with-idempotency\n  _shouldRetry(res, numRetries, maxRetries, error) {\n    if (error && numRetries === 0 && HttpClient.CONNECTION_CLOSED_ERROR_CODES.includes(error.code)) {\n      return true;\n    }\n    // Do not retry if we are out of retries.\n    if (numRetries >= maxRetries) {\n      return false;\n    }\n    // Retry on connection error.\n    if (!res) {\n      return true;\n    }\n    // The API may ask us not to retry (e.g., if doing so would be a no-op)\n    // or advise us to retry (e.g., in cases of lock timeouts); we defer to that.\n    if (res.getHeaders()['stripe-should-retry'] === 'false') {\n      return false;\n    }\n    if (res.getHeaders()['stripe-should-retry'] === 'true') {\n      return true;\n    }\n    // Retry on conflict errors.\n    if (res.getStatusCode() === 409) {\n      return true;\n    }\n    // Retry on 500, 503, and other internal errors.\n    //\n    // Note that we expect the stripe-should-retry header to be false\n    // in most cases when a 500 is returned, since our idempotency framework\n    // would typically replay it anyway.\n    if (res.getStatusCode() >= 500) {\n      return true;\n    }\n    return false;\n  },\n  _getSleepTimeInMS(numRetries) {\n    let retryAfter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const initialNetworkRetryDelay = this._stripe.getInitialNetworkRetryDelay();\n    const maxNetworkRetryDelay = this._stripe.getMaxNetworkRetryDelay();\n    // Apply exponential backoff with initialNetworkRetryDelay on the\n    // number of numRetries so far as inputs. Do not allow the number to exceed\n    // maxNetworkRetryDelay.\n    let sleepSeconds = Math.min(initialNetworkRetryDelay * Math.pow(numRetries - 1, 2), maxNetworkRetryDelay);\n    // Apply some jitter by randomizing the value in the range of\n    // (sleepSeconds / 2) to (sleepSeconds).\n    sleepSeconds *= 0.5 * (1 + Math.random());\n    // But never sleep less than the base sleep seconds.\n    sleepSeconds = Math.max(initialNetworkRetryDelay, sleepSeconds);\n    // And never sleep less than the time the API asks us to wait, assuming it's a reasonable ask.\n    if (Number.isInteger(retryAfter) && retryAfter <= MAX_RETRY_AFTER_WAIT) {\n      sleepSeconds = Math.max(sleepSeconds, retryAfter);\n    }\n    return sleepSeconds * 1000;\n  },\n  // Max retries can be set on a per request basis. Favor those over the global setting\n  _getMaxNetworkRetries() {\n    let settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return settings.maxNetworkRetries && Number.isInteger(settings.maxNetworkRetries) ? settings.maxNetworkRetries : this._stripe.getMaxNetworkRetries();\n  },\n  _defaultIdempotencyKey(method, settings) {\n    // If this is a POST and we allow multiple retries, ensure an idempotency key.\n    const maxRetries = this._getMaxNetworkRetries(settings);\n    if (method === 'POST' && maxRetries > 0) {\n      return `stripe-node-retry-${utils.uuid4()}`;\n    }\n    return null;\n  },\n  _makeHeaders(auth, contentLength, apiVersion, clientUserAgent, method, userSuppliedHeaders, userSuppliedSettings) {\n    const defaultHeaders = {\n      // Use specified auth token or use default from this stripe instance:\n      Authorization: auth ? `Bearer ${auth}` : this._stripe.getApiField('auth'),\n      Accept: 'application/json',\n      'Content-Type': 'application/x-www-form-urlencoded',\n      'User-Agent': this._getUserAgentString(),\n      'X-Stripe-Client-User-Agent': clientUserAgent,\n      'X-Stripe-Client-Telemetry': this._getTelemetryHeader(),\n      'Stripe-Version': apiVersion,\n      'Stripe-Account': this._stripe.getApiField('stripeAccount'),\n      'Idempotency-Key': this._defaultIdempotencyKey(method, userSuppliedSettings)\n    };\n    // As per https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.2:\n    //   A user agent SHOULD send a Content-Length in a request message when\n    //   no Transfer-Encoding is sent and the request method defines a meaning\n    //   for an enclosed payload body.  For example, a Content-Length header\n    //   field is normally sent in a POST request even when the value is 0\n    //   (indicating an empty payload body).  A user agent SHOULD NOT send a\n    //   Content-Length header field when the request message does not contain\n    //   a payload body and the method semantics do not anticipate such a\n    //   body.\n    //\n    // These method types are expected to have bodies and so we should always\n    // include a Content-Length.\n    const methodHasPayload = method == 'POST' || method == 'PUT' || method == 'PATCH';\n    // If a content length was specified, we always include it regardless of\n    // whether the method semantics anticipate such a body. This keeps us\n    // consistent with historical behavior. We do however want to warn on this\n    // and fix these cases as they are semantically incorrect.\n    if (methodHasPayload || contentLength) {\n      if (!methodHasPayload) {\n        utils.emitWarning(`${method} method had non-zero contentLength but no payload is expected for this verb`);\n      }\n      defaultHeaders['Content-Length'] = contentLength;\n    }\n    return Object.assign(utils.removeNullish(defaultHeaders),\n    // If the user supplied, say 'idempotency-key', override instead of appending by ensuring caps are the same.\n    utils.normalizeHeaders(userSuppliedHeaders));\n  },\n  _getUserAgentString() {\n    const packageVersion = this._stripe.getConstant('PACKAGE_VERSION');\n    const appInfo = this._stripe._appInfo ? this._stripe.getAppInfoAsString() : '';\n    return `Stripe/v1 NodeBindings/${packageVersion} ${appInfo}`.trim();\n  },\n  _getTelemetryHeader() {\n    if (this._stripe.getTelemetryEnabled() && this._stripe._prevRequestMetrics.length > 0) {\n      const metrics = this._stripe._prevRequestMetrics.shift();\n      return JSON.stringify({\n        last_request_metrics: metrics\n      });\n    }\n  },\n  _recordRequestMetrics(requestId, requestDurationMs) {\n    if (this._stripe.getTelemetryEnabled() && requestId) {\n      if (this._stripe._prevRequestMetrics.length > StripeResource.MAX_BUFFERED_REQUEST_METRICS) {\n        utils.emitWarning('Request metrics buffer is full, dropping telemetry message.');\n      } else {\n        this._stripe._prevRequestMetrics.push({\n          request_id: requestId,\n          request_duration_ms: requestDurationMs\n        });\n      }\n    }\n  },\n  _request(method, host, path, data, auth) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    let callback = arguments.length > 6 ? arguments[6] : undefined;\n    let requestData;\n    const retryRequest = (requestFn, apiVersion, headers, requestRetries, retryAfter) => {\n      return setTimeout(requestFn, this._getSleepTimeInMS(requestRetries, retryAfter), apiVersion, headers, requestRetries + 1);\n    };\n    const makeRequest = (apiVersion, headers, numRetries) => {\n      // timeout can be set on a per-request basis. Favor that over the global setting\n      const timeout = options.settings && options.settings.timeout && Number.isInteger(options.settings.timeout) && options.settings.timeout >= 0 ? options.settings.timeout : this._stripe.getApiField('timeout');\n      const req = this._stripe.getApiField('httpClient').makeRequest(host || this._stripe.getApiField('host'), this._stripe.getApiField('port'), path, method, headers, requestData, this._stripe.getApiField('protocol'), timeout);\n      const requestStartTime = Date.now();\n      // @ts-ignore\n      const requestEvent = utils.removeNullish({\n        api_version: apiVersion,\n        account: headers['Stripe-Account'],\n        idempotency_key: headers['Idempotency-Key'],\n        method,\n        path,\n        request_start_time: requestStartTime\n      });\n      const requestRetries = numRetries || 0;\n      const maxRetries = this._getMaxNetworkRetries(options.settings || {});\n      this._stripe._emitter.emit('request', requestEvent);\n      req.then(res => {\n        if (this._shouldRetry(res, requestRetries, maxRetries)) {\n          return retryRequest(makeRequest, apiVersion, headers, requestRetries,\n          // @ts-ignore\n          res.getHeaders()['retry-after']);\n        } else if (options.streaming && res.getStatusCode() < 400) {\n          return this._streamingResponseHandler(requestEvent, callback)(res);\n        } else {\n          return this._jsonResponseHandler(requestEvent, callback)(res);\n        }\n      }).catch(error => {\n        if (this._shouldRetry(null, requestRetries, maxRetries, error)) {\n          return retryRequest(makeRequest, apiVersion, headers, requestRetries, null);\n        } else {\n          const isTimeoutError = error.code && error.code === HttpClient.TIMEOUT_ERROR_CODE;\n          return callback.call(this, new StripeConnectionError({\n            message: isTimeoutError ? `Request aborted due to timeout being reached (${timeout}ms)` : this._generateConnectionErrorMessage(requestRetries),\n            // @ts-ignore\n            detail: error\n          }));\n        }\n      });\n    };\n    const prepareAndMakeRequest = (error, data) => {\n      if (error) {\n        return callback(error);\n      }\n      requestData = data;\n      this._stripe.getClientUserAgent(clientUserAgent => {\n        const apiVersion = this._stripe.getApiField('version');\n        const headers = this._makeHeaders(auth, requestData.length, apiVersion, clientUserAgent, method, options.headers, options.settings);\n        makeRequest(apiVersion, headers, 0);\n      });\n    };\n    if (this.requestDataProcessor) {\n      this.requestDataProcessor(method, data, options.headers, prepareAndMakeRequest);\n    } else {\n      prepareAndMakeRequest(null, utils.stringifyRequestData(data || {}));\n    }\n  }\n};\nmodule.exports = StripeResource;","map":{"version":3,"names":["utils","require","_Error","StripeAPIError","StripeAuthenticationError","StripeConnectionError","StripeError","StripePermissionError","StripeRateLimitError","HttpClient","StripeResource","extend","protoExtend","method","MAX_BUFFERED_REQUEST_METRICS","MAX_RETRY_AFTER_WAIT","stripe","deprecatedUrlData","_stripe","Error","basePath","makeURLInterpolator","getApiField","resourcePath","path","initialize","arguments","prototype","requestDataProcessor","validateRequest","createFullPath","commandPath","urlData","urlParts","computedCommandPath","push","_joinUrlParts","createResourcePathWithSymbols","pathWithSymbols","parts","join","replace","_addHeadersDirectlyToObject","obj","headers","requestId","stripeAccount","apiVersion","idempotencyKey","_makeResponseEvent","requestEvent","statusCode","requestEndTime","Date","now","requestDurationMs","request_start_time","removeNullish","api_version","account","idempotency_key","status","request_id","_getRequestId","elapsed","request_end_time","_streamingResponseHandler","callback","res","getHeaders","streamCompleteCallback","responseEvent","getStatusCode","_emitter","emit","_recordRequestMetrics","stream","toStream","_jsonResponseHandler","toJSON","then","jsonResponse","error","err","type","message","error_description","generate","e","exception","rawResponse","getRawResponse","Object","defineProperty","enumerable","writable","value","call","_generateConnectionErrorMessage","requestRetries","_shouldRetry","numRetries","maxRetries","CONNECTION_CLOSED_ERROR_CODES","includes","code","_getSleepTimeInMS","retryAfter","initialNetworkRetryDelay","getInitialNetworkRetryDelay","maxNetworkRetryDelay","getMaxNetworkRetryDelay","sleepSeconds","Math","min","pow","random","max","Number","isInteger","_getMaxNetworkRetries","settings","maxNetworkRetries","getMaxNetworkRetries","_defaultIdempotencyKey","uuid4","_makeHeaders","auth","contentLength","clientUserAgent","userSuppliedHeaders","userSuppliedSettings","defaultHeaders","Authorization","Accept","_getUserAgentString","_getTelemetryHeader","methodHasPayload","emitWarning","assign","normalizeHeaders","packageVersion","getConstant","appInfo","_appInfo","getAppInfoAsString","trim","getTelemetryEnabled","_prevRequestMetrics","length","metrics","shift","JSON","stringify","last_request_metrics","request_duration_ms","_request","host","data","options","requestData","retryRequest","requestFn","setTimeout","makeRequest","timeout","req","requestStartTime","streaming","catch","isTimeoutError","TIMEOUT_ERROR_CODE","detail","prepareAndMakeRequest","getClientUserAgent","stringifyRequestData","module","exports"],"sources":["C:/Users/galia/OneDrive/Escritorio/rent-a-bike-app/node_modules/stripe/lib/StripeResource.js"],"sourcesContent":["'use strict';\nconst utils = require('./utils');\nconst _Error = require('./Error');\nconst {\n  StripeAPIError,\n  StripeAuthenticationError,\n  StripeConnectionError,\n  StripeError,\n  StripePermissionError,\n  StripeRateLimitError,\n} = _Error;\nconst {HttpClient} = require('./net/HttpClient');\n// Provide extension mechanism for Stripe Resource Sub-Classes\nStripeResource.extend = utils.protoExtend;\n// Expose method-creator\nStripeResource.method = require('./StripeMethod');\nStripeResource.MAX_BUFFERED_REQUEST_METRICS = 100;\nconst MAX_RETRY_AFTER_WAIT = 60;\n/**\n * Encapsulates request logic for a Stripe Resource\n */\nfunction StripeResource(stripe, deprecatedUrlData) {\n  this._stripe = stripe;\n  if (deprecatedUrlData) {\n    throw new Error(\n      'Support for curried url params was dropped in stripe-node v7.0.0. Instead, pass two ids.'\n    );\n  }\n  this.basePath = utils.makeURLInterpolator(\n    // @ts-ignore changing type of basePath\n    this.basePath || stripe.getApiField('basePath')\n  );\n  // @ts-ignore changing type of path\n  this.resourcePath = this.path;\n  // @ts-ignore changing type of path\n  this.path = utils.makeURLInterpolator(this.path);\n  this.initialize(...arguments);\n}\nStripeResource.prototype = {\n  _stripe: null,\n  // @ts-ignore the type of path changes in ctor\n  path: '',\n  resourcePath: '',\n  // Methods that don't use the API's default '/v1' path can override it with this setting.\n  basePath: null,\n  initialize() {},\n  // Function to override the default data processor. This allows full control\n  // over how a StripeResource's request data will get converted into an HTTP\n  // body. This is useful for non-standard HTTP requests. The function should\n  // take method name, data, and headers as arguments.\n  requestDataProcessor: null,\n  // Function to add a validation checks before sending the request, errors should\n  // be thrown, and they will be passed to the callback/promise.\n  validateRequest: null,\n  createFullPath(commandPath, urlData) {\n    const urlParts = [this.basePath(urlData), this.path(urlData)];\n    if (typeof commandPath === 'function') {\n      const computedCommandPath = commandPath(urlData);\n      // If we have no actual command path, we just omit it to avoid adding a\n      // trailing slash. This is important for top-level listing requests, which\n      // do not have a command path.\n      if (computedCommandPath) {\n        urlParts.push(computedCommandPath);\n      }\n    } else {\n      urlParts.push(commandPath);\n    }\n    return this._joinUrlParts(urlParts);\n  },\n  // Creates a relative resource path with symbols left in (unlike\n  // createFullPath which takes some data to replace them with). For example it\n  // might produce: /invoices/{id}\n  createResourcePathWithSymbols(pathWithSymbols) {\n    // If there is no path beyond the resource path, we want to produce just\n    // /<resource path> rather than /<resource path>/.\n    if (pathWithSymbols) {\n      return `/${this._joinUrlParts([this.resourcePath, pathWithSymbols])}`;\n    } else {\n      return `/${this.resourcePath}`;\n    }\n  },\n  _joinUrlParts(parts) {\n    // Replace any accidentally doubled up slashes. This previously used\n    // path.join, which would do this as well. Unfortunately we need to do this\n    // as the functions for creating paths are technically part of the public\n    // interface and so we need to preserve backwards compatibility.\n    return parts.join('/').replace(/\\/{2,}/g, '/');\n  },\n  _addHeadersDirectlyToObject(obj, headers) {\n    // For convenience, make some headers easily accessible on\n    // lastResponse.\n    // NOTE: Stripe responds with lowercase header names/keys.\n    obj.requestId = headers['request-id'];\n    obj.stripeAccount = obj.stripeAccount || headers['stripe-account'];\n    obj.apiVersion = obj.apiVersion || headers['stripe-version'];\n    obj.idempotencyKey = obj.idempotencyKey || headers['idempotency-key'];\n  },\n  _makeResponseEvent(requestEvent, statusCode, headers) {\n    const requestEndTime = Date.now();\n    const requestDurationMs = requestEndTime - requestEvent.request_start_time;\n    return utils.removeNullish({\n      api_version: headers['stripe-version'],\n      account: headers['stripe-account'],\n      idempotency_key: headers['idempotency-key'],\n      method: requestEvent.method,\n      path: requestEvent.path,\n      status: statusCode,\n      request_id: this._getRequestId(headers),\n      elapsed: requestDurationMs,\n      request_start_time: requestEvent.request_start_time,\n      request_end_time: requestEndTime,\n    });\n  },\n  _getRequestId(headers) {\n    return headers['request-id'];\n  },\n  /**\n   * Used by methods with spec.streaming === true. For these methods, we do not\n   * buffer successful responses into memory or do parse them into stripe\n   * objects, we delegate that all of that to the user and pass back the raw\n   * http.Response object to the callback.\n   *\n   * (Unsuccessful responses shouldn't make it here, they should\n   * still be buffered/parsed and handled by _jsonResponseHandler -- see\n   * makeRequest)\n   */\n  _streamingResponseHandler(requestEvent, callback) {\n    return (res) => {\n      const headers = res.getHeaders();\n      const streamCompleteCallback = () => {\n        const responseEvent = this._makeResponseEvent(\n          requestEvent,\n          res.getStatusCode(),\n          headers\n        );\n        this._stripe._emitter.emit('response', responseEvent);\n        this._recordRequestMetrics(\n          this._getRequestId(headers),\n          responseEvent.elapsed\n        );\n      };\n      const stream = res.toStream(streamCompleteCallback);\n      // This is here for backwards compatibility, as the stream is a raw\n      // HTTP response in Node and the legacy behavior was to mutate this\n      // response.\n      this._addHeadersDirectlyToObject(stream, headers);\n      return callback(null, stream);\n    };\n  },\n  /**\n   * Default handler for Stripe responses. Buffers the response into memory,\n   * parses the JSON and returns it (i.e. passes it to the callback) if there\n   * is no \"error\" field. Otherwise constructs/passes an appropriate Error.\n   */\n  _jsonResponseHandler(requestEvent, callback) {\n    return (res) => {\n      const headers = res.getHeaders();\n      const requestId = this._getRequestId(headers);\n      const statusCode = res.getStatusCode();\n      const responseEvent = this._makeResponseEvent(\n        requestEvent,\n        statusCode,\n        headers\n      );\n      this._stripe._emitter.emit('response', responseEvent);\n      res\n        .toJSON()\n        .then(\n          (jsonResponse) => {\n            if (jsonResponse.error) {\n              let err;\n              // Convert OAuth error responses into a standard format\n              // so that the rest of the error logic can be shared\n              if (typeof jsonResponse.error === 'string') {\n                jsonResponse.error = {\n                  type: jsonResponse.error,\n                  message: jsonResponse.error_description,\n                };\n              }\n              jsonResponse.error.headers = headers;\n              jsonResponse.error.statusCode = statusCode;\n              jsonResponse.error.requestId = requestId;\n              if (statusCode === 401) {\n                err = new StripeAuthenticationError(jsonResponse.error);\n              } else if (statusCode === 403) {\n                err = new StripePermissionError(jsonResponse.error);\n              } else if (statusCode === 429) {\n                err = new StripeRateLimitError(jsonResponse.error);\n              } else {\n                err = StripeError.generate(jsonResponse.error);\n              }\n              throw err;\n            }\n            return jsonResponse;\n          },\n          (e) => {\n            throw new StripeAPIError({\n              message: 'Invalid JSON received from the Stripe API',\n              exception: e,\n              requestId: headers['request-id'],\n            });\n          }\n        )\n        .then(\n          (jsonResponse) => {\n            this._recordRequestMetrics(requestId, responseEvent.elapsed);\n            // Expose raw response object.\n            const rawResponse = res.getRawResponse();\n            this._addHeadersDirectlyToObject(rawResponse, headers);\n            Object.defineProperty(jsonResponse, 'lastResponse', {\n              enumerable: false,\n              writable: false,\n              value: rawResponse,\n            });\n            callback.call(this, null, jsonResponse);\n          },\n          (e) => callback.call(this, e, null)\n        );\n    };\n  },\n  _generateConnectionErrorMessage(requestRetries) {\n    return `An error occurred with our connection to Stripe.${\n      requestRetries > 0 ? ` Request was retried ${requestRetries} times.` : ''\n    }`;\n  },\n  // For more on when and how to retry API requests, see https://stripe.com/docs/error-handling#safely-retrying-requests-with-idempotency\n  _shouldRetry(res, numRetries, maxRetries, error) {\n    if (\n      error &&\n      numRetries === 0 &&\n      HttpClient.CONNECTION_CLOSED_ERROR_CODES.includes(error.code)\n    ) {\n      return true;\n    }\n    // Do not retry if we are out of retries.\n    if (numRetries >= maxRetries) {\n      return false;\n    }\n    // Retry on connection error.\n    if (!res) {\n      return true;\n    }\n    // The API may ask us not to retry (e.g., if doing so would be a no-op)\n    // or advise us to retry (e.g., in cases of lock timeouts); we defer to that.\n    if (res.getHeaders()['stripe-should-retry'] === 'false') {\n      return false;\n    }\n    if (res.getHeaders()['stripe-should-retry'] === 'true') {\n      return true;\n    }\n    // Retry on conflict errors.\n    if (res.getStatusCode() === 409) {\n      return true;\n    }\n    // Retry on 500, 503, and other internal errors.\n    //\n    // Note that we expect the stripe-should-retry header to be false\n    // in most cases when a 500 is returned, since our idempotency framework\n    // would typically replay it anyway.\n    if (res.getStatusCode() >= 500) {\n      return true;\n    }\n    return false;\n  },\n  _getSleepTimeInMS(numRetries, retryAfter = null) {\n    const initialNetworkRetryDelay = this._stripe.getInitialNetworkRetryDelay();\n    const maxNetworkRetryDelay = this._stripe.getMaxNetworkRetryDelay();\n    // Apply exponential backoff with initialNetworkRetryDelay on the\n    // number of numRetries so far as inputs. Do not allow the number to exceed\n    // maxNetworkRetryDelay.\n    let sleepSeconds = Math.min(\n      initialNetworkRetryDelay * Math.pow(numRetries - 1, 2),\n      maxNetworkRetryDelay\n    );\n    // Apply some jitter by randomizing the value in the range of\n    // (sleepSeconds / 2) to (sleepSeconds).\n    sleepSeconds *= 0.5 * (1 + Math.random());\n    // But never sleep less than the base sleep seconds.\n    sleepSeconds = Math.max(initialNetworkRetryDelay, sleepSeconds);\n    // And never sleep less than the time the API asks us to wait, assuming it's a reasonable ask.\n    if (Number.isInteger(retryAfter) && retryAfter <= MAX_RETRY_AFTER_WAIT) {\n      sleepSeconds = Math.max(sleepSeconds, retryAfter);\n    }\n    return sleepSeconds * 1000;\n  },\n  // Max retries can be set on a per request basis. Favor those over the global setting\n  _getMaxNetworkRetries(settings = {}) {\n    return settings.maxNetworkRetries &&\n      Number.isInteger(settings.maxNetworkRetries)\n      ? settings.maxNetworkRetries\n      : this._stripe.getMaxNetworkRetries();\n  },\n  _defaultIdempotencyKey(method, settings) {\n    // If this is a POST and we allow multiple retries, ensure an idempotency key.\n    const maxRetries = this._getMaxNetworkRetries(settings);\n    if (method === 'POST' && maxRetries > 0) {\n      return `stripe-node-retry-${utils.uuid4()}`;\n    }\n    return null;\n  },\n  _makeHeaders(\n    auth,\n    contentLength,\n    apiVersion,\n    clientUserAgent,\n    method,\n    userSuppliedHeaders,\n    userSuppliedSettings\n  ) {\n    const defaultHeaders = {\n      // Use specified auth token or use default from this stripe instance:\n      Authorization: auth ? `Bearer ${auth}` : this._stripe.getApiField('auth'),\n      Accept: 'application/json',\n      'Content-Type': 'application/x-www-form-urlencoded',\n      'User-Agent': this._getUserAgentString(),\n      'X-Stripe-Client-User-Agent': clientUserAgent,\n      'X-Stripe-Client-Telemetry': this._getTelemetryHeader(),\n      'Stripe-Version': apiVersion,\n      'Stripe-Account': this._stripe.getApiField('stripeAccount'),\n      'Idempotency-Key': this._defaultIdempotencyKey(\n        method,\n        userSuppliedSettings\n      ),\n    };\n    // As per https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.2:\n    //   A user agent SHOULD send a Content-Length in a request message when\n    //   no Transfer-Encoding is sent and the request method defines a meaning\n    //   for an enclosed payload body.  For example, a Content-Length header\n    //   field is normally sent in a POST request even when the value is 0\n    //   (indicating an empty payload body).  A user agent SHOULD NOT send a\n    //   Content-Length header field when the request message does not contain\n    //   a payload body and the method semantics do not anticipate such a\n    //   body.\n    //\n    // These method types are expected to have bodies and so we should always\n    // include a Content-Length.\n    const methodHasPayload =\n      method == 'POST' || method == 'PUT' || method == 'PATCH';\n    // If a content length was specified, we always include it regardless of\n    // whether the method semantics anticipate such a body. This keeps us\n    // consistent with historical behavior. We do however want to warn on this\n    // and fix these cases as they are semantically incorrect.\n    if (methodHasPayload || contentLength) {\n      if (!methodHasPayload) {\n        utils.emitWarning(\n          `${method} method had non-zero contentLength but no payload is expected for this verb`\n        );\n      }\n      defaultHeaders['Content-Length'] = contentLength;\n    }\n    return Object.assign(\n      utils.removeNullish(defaultHeaders),\n      // If the user supplied, say 'idempotency-key', override instead of appending by ensuring caps are the same.\n      utils.normalizeHeaders(userSuppliedHeaders)\n    );\n  },\n  _getUserAgentString() {\n    const packageVersion = this._stripe.getConstant('PACKAGE_VERSION');\n    const appInfo = this._stripe._appInfo\n      ? this._stripe.getAppInfoAsString()\n      : '';\n    return `Stripe/v1 NodeBindings/${packageVersion} ${appInfo}`.trim();\n  },\n  _getTelemetryHeader() {\n    if (\n      this._stripe.getTelemetryEnabled() &&\n      this._stripe._prevRequestMetrics.length > 0\n    ) {\n      const metrics = this._stripe._prevRequestMetrics.shift();\n      return JSON.stringify({\n        last_request_metrics: metrics,\n      });\n    }\n  },\n  _recordRequestMetrics(requestId, requestDurationMs) {\n    if (this._stripe.getTelemetryEnabled() && requestId) {\n      if (\n        this._stripe._prevRequestMetrics.length >\n        StripeResource.MAX_BUFFERED_REQUEST_METRICS\n      ) {\n        utils.emitWarning(\n          'Request metrics buffer is full, dropping telemetry message.'\n        );\n      } else {\n        this._stripe._prevRequestMetrics.push({\n          request_id: requestId,\n          request_duration_ms: requestDurationMs,\n        });\n      }\n    }\n  },\n  _request(method, host, path, data, auth, options = {}, callback) {\n    let requestData;\n    const retryRequest = (\n      requestFn,\n      apiVersion,\n      headers,\n      requestRetries,\n      retryAfter\n    ) => {\n      return setTimeout(\n        requestFn,\n        this._getSleepTimeInMS(requestRetries, retryAfter),\n        apiVersion,\n        headers,\n        requestRetries + 1\n      );\n    };\n    const makeRequest = (apiVersion, headers, numRetries) => {\n      // timeout can be set on a per-request basis. Favor that over the global setting\n      const timeout =\n        options.settings &&\n        options.settings.timeout &&\n        Number.isInteger(options.settings.timeout) &&\n        options.settings.timeout >= 0\n          ? options.settings.timeout\n          : this._stripe.getApiField('timeout');\n      const req = this._stripe\n        .getApiField('httpClient')\n        .makeRequest(\n          host || this._stripe.getApiField('host'),\n          this._stripe.getApiField('port'),\n          path,\n          method,\n          headers,\n          requestData,\n          this._stripe.getApiField('protocol'),\n          timeout\n        );\n      const requestStartTime = Date.now();\n      // @ts-ignore\n      const requestEvent = utils.removeNullish({\n        api_version: apiVersion,\n        account: headers['Stripe-Account'],\n        idempotency_key: headers['Idempotency-Key'],\n        method,\n        path,\n        request_start_time: requestStartTime,\n      });\n      const requestRetries = numRetries || 0;\n      const maxRetries = this._getMaxNetworkRetries(options.settings || {});\n      this._stripe._emitter.emit('request', requestEvent);\n      req\n        .then((res) => {\n          if (this._shouldRetry(res, requestRetries, maxRetries)) {\n            return retryRequest(\n              makeRequest,\n              apiVersion,\n              headers,\n              requestRetries,\n              // @ts-ignore\n              res.getHeaders()['retry-after']\n            );\n          } else if (options.streaming && res.getStatusCode() < 400) {\n            return this._streamingResponseHandler(requestEvent, callback)(res);\n          } else {\n            return this._jsonResponseHandler(requestEvent, callback)(res);\n          }\n        })\n        .catch((error) => {\n          if (this._shouldRetry(null, requestRetries, maxRetries, error)) {\n            return retryRequest(\n              makeRequest,\n              apiVersion,\n              headers,\n              requestRetries,\n              null\n            );\n          } else {\n            const isTimeoutError =\n              error.code && error.code === HttpClient.TIMEOUT_ERROR_CODE;\n            return callback.call(\n              this,\n              new StripeConnectionError({\n                message: isTimeoutError\n                  ? `Request aborted due to timeout being reached (${timeout}ms)`\n                  : this._generateConnectionErrorMessage(requestRetries),\n                // @ts-ignore\n                detail: error,\n              })\n            );\n          }\n        });\n    };\n    const prepareAndMakeRequest = (error, data) => {\n      if (error) {\n        return callback(error);\n      }\n      requestData = data;\n      this._stripe.getClientUserAgent((clientUserAgent) => {\n        const apiVersion = this._stripe.getApiField('version');\n        const headers = this._makeHeaders(\n          auth,\n          requestData.length,\n          apiVersion,\n          clientUserAgent,\n          method,\n          options.headers,\n          options.settings\n        );\n        makeRequest(apiVersion, headers, 0);\n      });\n    };\n    if (this.requestDataProcessor) {\n      this.requestDataProcessor(\n        method,\n        data,\n        options.headers,\n        prepareAndMakeRequest\n      );\n    } else {\n      prepareAndMakeRequest(null, utils.stringifyRequestData(data || {}));\n    }\n  },\n};\nmodule.exports = StripeResource;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}