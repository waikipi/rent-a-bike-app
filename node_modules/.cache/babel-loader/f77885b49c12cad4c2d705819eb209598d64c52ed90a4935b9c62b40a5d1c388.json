{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst RuntimeGlobals = require(\"./RuntimeGlobals\");\nconst WebpackError = require(\"./WebpackError\");\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\nconst BasicEvaluatedExpression = require(\"./javascript/BasicEvaluatedExpression\");\nconst {\n  evaluateToString,\n  toConstantDependency\n} = require(\"./javascript/JavascriptParserHelpers\");\nconst createHash = require(\"./util/createHash\");\n\n/** @typedef {import(\"estree\").Expression} Expression */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./NormalModule\")} NormalModule */\n/** @typedef {import(\"./RuntimeTemplate\")} RuntimeTemplate */\n/** @typedef {import(\"./javascript/JavascriptParser\")} JavascriptParser */\n\n/** @typedef {null|undefined|RegExp|Function|string|number|boolean|bigint|undefined} CodeValuePrimitive */\n/** @typedef {RecursiveArrayOrRecord<CodeValuePrimitive|RuntimeValue>} CodeValue */\n\n/**\n * @typedef {Object} RuntimeValueOptions\n * @property {string[]=} fileDependencies\n * @property {string[]=} contextDependencies\n * @property {string[]=} missingDependencies\n * @property {string[]=} buildDependencies\n * @property {string|function(): string=} version\n */\n\nclass RuntimeValue {\n  /**\n   * @param {function({ module: NormalModule, key: string, readonly version: string | undefined }): CodeValuePrimitive} fn generator function\n   * @param {true | string[] | RuntimeValueOptions=} options options\n   */\n  constructor(fn, options) {\n    this.fn = fn;\n    if (Array.isArray(options)) {\n      options = {\n        fileDependencies: options\n      };\n    }\n    this.options = options || {};\n  }\n  get fileDependencies() {\n    return this.options === true ? true : this.options.fileDependencies;\n  }\n\n  /**\n   * @param {JavascriptParser} parser the parser\n   * @param {Map<string, string | Set<string>>} valueCacheVersions valueCacheVersions\n   * @param {string} key the defined key\n   * @returns {CodeValuePrimitive} code\n   */\n  exec(parser, valueCacheVersions, key) {\n    const buildInfo = parser.state.module.buildInfo;\n    if (this.options === true) {\n      buildInfo.cacheable = false;\n    } else {\n      if (this.options.fileDependencies) {\n        for (const dep of this.options.fileDependencies) {\n          buildInfo.fileDependencies.add(dep);\n        }\n      }\n      if (this.options.contextDependencies) {\n        for (const dep of this.options.contextDependencies) {\n          buildInfo.contextDependencies.add(dep);\n        }\n      }\n      if (this.options.missingDependencies) {\n        for (const dep of this.options.missingDependencies) {\n          buildInfo.missingDependencies.add(dep);\n        }\n      }\n      if (this.options.buildDependencies) {\n        for (const dep of this.options.buildDependencies) {\n          buildInfo.buildDependencies.add(dep);\n        }\n      }\n    }\n    return this.fn({\n      module: parser.state.module,\n      key,\n      get version() {\n        return (/** @type {string} */\n          valueCacheVersions.get(VALUE_DEP_PREFIX + key)\n        );\n      }\n    });\n  }\n  getCacheVersion() {\n    return this.options === true ? undefined : (typeof this.options.version === \"function\" ? this.options.version() : this.options.version) || \"unset\";\n  }\n}\n\n/**\n * @param {any[]|{[k: string]: any}} obj obj\n * @param {JavascriptParser} parser Parser\n * @param {Map<string, string | Set<string>>} valueCacheVersions valueCacheVersions\n * @param {string} key the defined key\n * @param {RuntimeTemplate} runtimeTemplate the runtime template\n * @param {boolean|undefined|null=} asiSafe asi safe (undefined: unknown, null: unneeded)\n * @returns {string} code converted to string that evaluates\n */\nconst stringifyObj = (obj, parser, valueCacheVersions, key, runtimeTemplate, asiSafe) => {\n  let code;\n  let arr = Array.isArray(obj);\n  if (arr) {\n    code = `[${obj.map(code => toCode(code, parser, valueCacheVersions, key, runtimeTemplate, null)).join(\",\")}]`;\n  } else {\n    code = `{${Object.keys(obj).map(key => {\n      const code = obj[key];\n      return JSON.stringify(key) + \":\" + toCode(code, parser, valueCacheVersions, key, runtimeTemplate, null);\n    }).join(\",\")}}`;\n  }\n  switch (asiSafe) {\n    case null:\n      return code;\n    case true:\n      return arr ? code : `(${code})`;\n    case false:\n      return arr ? `;${code}` : `;(${code})`;\n    default:\n      return `/*#__PURE__*/Object(${code})`;\n  }\n};\n\n/**\n * Convert code to a string that evaluates\n * @param {CodeValue} code Code to evaluate\n * @param {JavascriptParser} parser Parser\n * @param {Map<string, string | Set<string>>} valueCacheVersions valueCacheVersions\n * @param {string} key the defined key\n * @param {RuntimeTemplate} runtimeTemplate the runtime template\n * @param {boolean|undefined|null=} asiSafe asi safe (undefined: unknown, null: unneeded)\n * @returns {string} code converted to string that evaluates\n */\nconst toCode = (code, parser, valueCacheVersions, key, runtimeTemplate, asiSafe) => {\n  if (code === null) {\n    return \"null\";\n  }\n  if (code === undefined) {\n    return \"undefined\";\n  }\n  if (Object.is(code, -0)) {\n    return \"-0\";\n  }\n  if (code instanceof RuntimeValue) {\n    return toCode(code.exec(parser, valueCacheVersions, key), parser, valueCacheVersions, key, runtimeTemplate, asiSafe);\n  }\n  if (code instanceof RegExp && code.toString) {\n    return code.toString();\n  }\n  if (typeof code === \"function\" && code.toString) {\n    return \"(\" + code.toString() + \")\";\n  }\n  if (typeof code === \"object\") {\n    return stringifyObj(code, parser, valueCacheVersions, key, runtimeTemplate, asiSafe);\n  }\n  if (typeof code === \"bigint\") {\n    return runtimeTemplate.supportsBigIntLiteral() ? `${code}n` : `BigInt(\"${code}\")`;\n  }\n  return code + \"\";\n};\nconst toCacheVersion = code => {\n  if (code === null) {\n    return \"null\";\n  }\n  if (code === undefined) {\n    return \"undefined\";\n  }\n  if (Object.is(code, -0)) {\n    return \"-0\";\n  }\n  if (code instanceof RuntimeValue) {\n    return code.getCacheVersion();\n  }\n  if (code instanceof RegExp && code.toString) {\n    return code.toString();\n  }\n  if (typeof code === \"function\" && code.toString) {\n    return \"(\" + code.toString() + \")\";\n  }\n  if (typeof code === \"object\") {\n    const items = Object.keys(code).map(key => ({\n      key,\n      value: toCacheVersion(code[key])\n    }));\n    if (items.some(_ref => {\n      let {\n        value\n      } = _ref;\n      return value === undefined;\n    })) return undefined;\n    return `{${items.map(_ref2 => {\n      let {\n        key,\n        value\n      } = _ref2;\n      return `${key}: ${value}`;\n    }).join(\", \")}}`;\n  }\n  if (typeof code === \"bigint\") {\n    return `${code}n`;\n  }\n  return code + \"\";\n};\nconst VALUE_DEP_PREFIX = \"webpack/DefinePlugin \";\nconst VALUE_DEP_MAIN = \"webpack/DefinePlugin_hash\";\nclass DefinePlugin {\n  /**\n   * Create a new define plugin\n   * @param {Record<string, CodeValue>} definitions A map of global object definitions\n   */\n  constructor(definitions) {\n    this.definitions = definitions;\n  }\n\n  /**\n   * @param {function({ module: NormalModule, key: string, readonly version: string | undefined }): CodeValuePrimitive} fn generator function\n   * @param {true | string[] | RuntimeValueOptions=} options options\n   * @returns {RuntimeValue} runtime value\n   */\n  static runtimeValue(fn, options) {\n    return new RuntimeValue(fn, options);\n  }\n\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    const definitions = this.definitions;\n    compiler.hooks.compilation.tap(\"DefinePlugin\", (compilation, _ref3) => {\n      let {\n        normalModuleFactory\n      } = _ref3;\n      compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());\n      const {\n        runtimeTemplate\n      } = compilation;\n      const mainHash = createHash(compilation.outputOptions.hashFunction);\n      mainHash.update( /** @type {string} */compilation.valueCacheVersions.get(VALUE_DEP_MAIN) || \"\");\n\n      /**\n       * Handler\n       * @param {JavascriptParser} parser Parser\n       * @returns {void}\n       */\n      const handler = parser => {\n        const mainValue = compilation.valueCacheVersions.get(VALUE_DEP_MAIN);\n        parser.hooks.program.tap(\"DefinePlugin\", () => {\n          const {\n            buildInfo\n          } = parser.state.module;\n          if (!buildInfo.valueDependencies) buildInfo.valueDependencies = new Map();\n          buildInfo.valueDependencies.set(VALUE_DEP_MAIN, mainValue);\n        });\n        const addValueDependency = key => {\n          const {\n            buildInfo\n          } = parser.state.module;\n          buildInfo.valueDependencies.set(VALUE_DEP_PREFIX + key, compilation.valueCacheVersions.get(VALUE_DEP_PREFIX + key));\n        };\n        const withValueDependency = (key, fn) => function () {\n          addValueDependency(key);\n          return fn(...arguments);\n        };\n\n        /**\n         * Walk definitions\n         * @param {Object} definitions Definitions map\n         * @param {string} prefix Prefix string\n         * @returns {void}\n         */\n        const walkDefinitions = (definitions, prefix) => {\n          Object.keys(definitions).forEach(key => {\n            const code = definitions[key];\n            if (code && typeof code === \"object\" && !(code instanceof RuntimeValue) && !(code instanceof RegExp)) {\n              walkDefinitions(code, prefix + key + \".\");\n              applyObjectDefine(prefix + key, code);\n              return;\n            }\n            applyDefineKey(prefix, key);\n            applyDefine(prefix + key, code);\n          });\n        };\n\n        /**\n         * Apply define key\n         * @param {string} prefix Prefix\n         * @param {string} key Key\n         * @returns {void}\n         */\n        const applyDefineKey = (prefix, key) => {\n          const splittedKey = key.split(\".\");\n          splittedKey.slice(1).forEach((_, i) => {\n            const fullKey = prefix + splittedKey.slice(0, i + 1).join(\".\");\n            parser.hooks.canRename.for(fullKey).tap(\"DefinePlugin\", () => {\n              addValueDependency(key);\n              return true;\n            });\n          });\n        };\n\n        /**\n         * Apply Code\n         * @param {string} key Key\n         * @param {CodeValue} code Code\n         * @returns {void}\n         */\n        const applyDefine = (key, code) => {\n          const originalKey = key;\n          const isTypeof = /^typeof\\s+/.test(key);\n          if (isTypeof) key = key.replace(/^typeof\\s+/, \"\");\n          let recurse = false;\n          let recurseTypeof = false;\n          if (!isTypeof) {\n            parser.hooks.canRename.for(key).tap(\"DefinePlugin\", () => {\n              addValueDependency(originalKey);\n              return true;\n            });\n            parser.hooks.evaluateIdentifier.for(key).tap(\"DefinePlugin\", expr => {\n              /**\n               * this is needed in case there is a recursion in the DefinePlugin\n               * to prevent an endless recursion\n               * e.g.: new DefinePlugin({\n               * \"a\": \"b\",\n               * \"b\": \"a\"\n               * });\n               */\n              if (recurse) return;\n              addValueDependency(originalKey);\n              recurse = true;\n              const res = parser.evaluate(toCode(code, parser, compilation.valueCacheVersions, key, runtimeTemplate, null));\n              recurse = false;\n              res.setRange(expr.range);\n              return res;\n            });\n            parser.hooks.expression.for(key).tap(\"DefinePlugin\", expr => {\n              addValueDependency(originalKey);\n              const strCode = toCode(code, parser, compilation.valueCacheVersions, originalKey, runtimeTemplate, !parser.isAsiPosition(expr.range[0]));\n              if (/__webpack_require__\\s*(!?\\.)/.test(strCode)) {\n                return toConstantDependency(parser, strCode, [RuntimeGlobals.require])(expr);\n              } else if (/__webpack_require__/.test(strCode)) {\n                return toConstantDependency(parser, strCode, [RuntimeGlobals.requireScope])(expr);\n              } else {\n                return toConstantDependency(parser, strCode)(expr);\n              }\n            });\n          }\n          parser.hooks.evaluateTypeof.for(key).tap(\"DefinePlugin\", expr => {\n            /**\n             * this is needed in case there is a recursion in the DefinePlugin\n             * to prevent an endless recursion\n             * e.g.: new DefinePlugin({\n             * \"typeof a\": \"typeof b\",\n             * \"typeof b\": \"typeof a\"\n             * });\n             */\n            if (recurseTypeof) return;\n            recurseTypeof = true;\n            addValueDependency(originalKey);\n            const codeCode = toCode(code, parser, compilation.valueCacheVersions, originalKey, runtimeTemplate, null);\n            const typeofCode = isTypeof ? codeCode : \"typeof (\" + codeCode + \")\";\n            const res = parser.evaluate(typeofCode);\n            recurseTypeof = false;\n            res.setRange(expr.range);\n            return res;\n          });\n          parser.hooks.typeof.for(key).tap(\"DefinePlugin\", expr => {\n            addValueDependency(originalKey);\n            const codeCode = toCode(code, parser, compilation.valueCacheVersions, originalKey, runtimeTemplate, null);\n            const typeofCode = isTypeof ? codeCode : \"typeof (\" + codeCode + \")\";\n            const res = parser.evaluate(typeofCode);\n            if (!res.isString()) return;\n            return toConstantDependency(parser, JSON.stringify(res.string)).bind(parser)(expr);\n          });\n        };\n\n        /**\n         * Apply Object\n         * @param {string} key Key\n         * @param {Object} obj Object\n         * @returns {void}\n         */\n        const applyObjectDefine = (key, obj) => {\n          parser.hooks.canRename.for(key).tap(\"DefinePlugin\", () => {\n            addValueDependency(key);\n            return true;\n          });\n          parser.hooks.evaluateIdentifier.for(key).tap(\"DefinePlugin\", expr => {\n            addValueDependency(key);\n            return new BasicEvaluatedExpression().setTruthy().setSideEffects(false).setRange(expr.range);\n          });\n          parser.hooks.evaluateTypeof.for(key).tap(\"DefinePlugin\", withValueDependency(key, evaluateToString(\"object\")));\n          parser.hooks.expression.for(key).tap(\"DefinePlugin\", expr => {\n            addValueDependency(key);\n            const strCode = stringifyObj(obj, parser, compilation.valueCacheVersions, key, runtimeTemplate, !parser.isAsiPosition(expr.range[0]));\n            if (/__webpack_require__\\s*(!?\\.)/.test(strCode)) {\n              return toConstantDependency(parser, strCode, [RuntimeGlobals.require])(expr);\n            } else if (/__webpack_require__/.test(strCode)) {\n              return toConstantDependency(parser, strCode, [RuntimeGlobals.requireScope])(expr);\n            } else {\n              return toConstantDependency(parser, strCode)(expr);\n            }\n          });\n          parser.hooks.typeof.for(key).tap(\"DefinePlugin\", withValueDependency(key, toConstantDependency(parser, JSON.stringify(\"object\"))));\n        };\n        walkDefinitions(definitions, \"\");\n      };\n      normalModuleFactory.hooks.parser.for(\"javascript/auto\").tap(\"DefinePlugin\", handler);\n      normalModuleFactory.hooks.parser.for(\"javascript/dynamic\").tap(\"DefinePlugin\", handler);\n      normalModuleFactory.hooks.parser.for(\"javascript/esm\").tap(\"DefinePlugin\", handler);\n\n      /**\n       * Walk definitions\n       * @param {Object} definitions Definitions map\n       * @param {string} prefix Prefix string\n       * @returns {void}\n       */\n      const walkDefinitionsForValues = (definitions, prefix) => {\n        Object.keys(definitions).forEach(key => {\n          const code = definitions[key];\n          const version = toCacheVersion(code);\n          const name = VALUE_DEP_PREFIX + prefix + key;\n          mainHash.update(\"|\" + prefix + key);\n          const oldVersion = compilation.valueCacheVersions.get(name);\n          if (oldVersion === undefined) {\n            compilation.valueCacheVersions.set(name, version);\n          } else if (oldVersion !== version) {\n            const warning = new WebpackError(`DefinePlugin\\nConflicting values for '${prefix + key}'`);\n            warning.details = `'${oldVersion}' !== '${version}'`;\n            warning.hideStack = true;\n            compilation.warnings.push(warning);\n          }\n          if (code && typeof code === \"object\" && !(code instanceof RuntimeValue) && !(code instanceof RegExp)) {\n            walkDefinitionsForValues(code, prefix + key + \".\");\n          }\n        });\n      };\n      walkDefinitionsForValues(definitions, \"\");\n      compilation.valueCacheVersions.set(VALUE_DEP_MAIN, /** @type {string} */mainHash.digest(\"hex\").slice(0, 8));\n    });\n  }\n}\nmodule.exports = DefinePlugin;","map":{"version":3,"names":["RuntimeGlobals","require","WebpackError","ConstDependency","BasicEvaluatedExpression","evaluateToString","toConstantDependency","createHash","RuntimeValue","constructor","fn","options","Array","isArray","fileDependencies","exec","parser","valueCacheVersions","key","buildInfo","state","module","cacheable","dep","add","contextDependencies","missingDependencies","buildDependencies","version","get","VALUE_DEP_PREFIX","getCacheVersion","undefined","stringifyObj","obj","runtimeTemplate","asiSafe","code","arr","map","toCode","join","Object","keys","JSON","stringify","is","RegExp","toString","supportsBigIntLiteral","toCacheVersion","items","value","some","VALUE_DEP_MAIN","DefinePlugin","definitions","runtimeValue","apply","compiler","hooks","compilation","tap","normalModuleFactory","dependencyTemplates","set","Template","mainHash","outputOptions","hashFunction","update","handler","mainValue","program","valueDependencies","Map","addValueDependency","withValueDependency","walkDefinitions","prefix","forEach","applyObjectDefine","applyDefineKey","applyDefine","splittedKey","split","slice","_","i","fullKey","canRename","for","originalKey","isTypeof","test","replace","recurse","recurseTypeof","evaluateIdentifier","expr","res","evaluate","setRange","range","expression","strCode","isAsiPosition","requireScope","evaluateTypeof","codeCode","typeofCode","typeof","isString","string","bind","setTruthy","setSideEffects","walkDefinitionsForValues","name","oldVersion","warning","details","hideStack","warnings","push","digest","exports"],"sources":["C:/Users/galia/OneDrive/Escritorio/rent-a-bike-app/node_modules/webpack/lib/DefinePlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst RuntimeGlobals = require(\"./RuntimeGlobals\");\nconst WebpackError = require(\"./WebpackError\");\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\nconst BasicEvaluatedExpression = require(\"./javascript/BasicEvaluatedExpression\");\nconst {\n\tevaluateToString,\n\ttoConstantDependency\n} = require(\"./javascript/JavascriptParserHelpers\");\nconst createHash = require(\"./util/createHash\");\n\n/** @typedef {import(\"estree\").Expression} Expression */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./NormalModule\")} NormalModule */\n/** @typedef {import(\"./RuntimeTemplate\")} RuntimeTemplate */\n/** @typedef {import(\"./javascript/JavascriptParser\")} JavascriptParser */\n\n/** @typedef {null|undefined|RegExp|Function|string|number|boolean|bigint|undefined} CodeValuePrimitive */\n/** @typedef {RecursiveArrayOrRecord<CodeValuePrimitive|RuntimeValue>} CodeValue */\n\n/**\n * @typedef {Object} RuntimeValueOptions\n * @property {string[]=} fileDependencies\n * @property {string[]=} contextDependencies\n * @property {string[]=} missingDependencies\n * @property {string[]=} buildDependencies\n * @property {string|function(): string=} version\n */\n\nclass RuntimeValue {\n\t/**\n\t * @param {function({ module: NormalModule, key: string, readonly version: string | undefined }): CodeValuePrimitive} fn generator function\n\t * @param {true | string[] | RuntimeValueOptions=} options options\n\t */\n\tconstructor(fn, options) {\n\t\tthis.fn = fn;\n\t\tif (Array.isArray(options)) {\n\t\t\toptions = {\n\t\t\t\tfileDependencies: options\n\t\t\t};\n\t\t}\n\t\tthis.options = options || {};\n\t}\n\n\tget fileDependencies() {\n\t\treturn this.options === true ? true : this.options.fileDependencies;\n\t}\n\n\t/**\n\t * @param {JavascriptParser} parser the parser\n\t * @param {Map<string, string | Set<string>>} valueCacheVersions valueCacheVersions\n\t * @param {string} key the defined key\n\t * @returns {CodeValuePrimitive} code\n\t */\n\texec(parser, valueCacheVersions, key) {\n\t\tconst buildInfo = parser.state.module.buildInfo;\n\t\tif (this.options === true) {\n\t\t\tbuildInfo.cacheable = false;\n\t\t} else {\n\t\t\tif (this.options.fileDependencies) {\n\t\t\t\tfor (const dep of this.options.fileDependencies) {\n\t\t\t\t\tbuildInfo.fileDependencies.add(dep);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.options.contextDependencies) {\n\t\t\t\tfor (const dep of this.options.contextDependencies) {\n\t\t\t\t\tbuildInfo.contextDependencies.add(dep);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.options.missingDependencies) {\n\t\t\t\tfor (const dep of this.options.missingDependencies) {\n\t\t\t\t\tbuildInfo.missingDependencies.add(dep);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.options.buildDependencies) {\n\t\t\t\tfor (const dep of this.options.buildDependencies) {\n\t\t\t\t\tbuildInfo.buildDependencies.add(dep);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.fn({\n\t\t\tmodule: parser.state.module,\n\t\t\tkey,\n\t\t\tget version() {\n\t\t\t\treturn /** @type {string} */ (\n\t\t\t\t\tvalueCacheVersions.get(VALUE_DEP_PREFIX + key)\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t}\n\n\tgetCacheVersion() {\n\t\treturn this.options === true\n\t\t\t? undefined\n\t\t\t: (typeof this.options.version === \"function\"\n\t\t\t\t\t? this.options.version()\n\t\t\t\t\t: this.options.version) || \"unset\";\n\t}\n}\n\n/**\n * @param {any[]|{[k: string]: any}} obj obj\n * @param {JavascriptParser} parser Parser\n * @param {Map<string, string | Set<string>>} valueCacheVersions valueCacheVersions\n * @param {string} key the defined key\n * @param {RuntimeTemplate} runtimeTemplate the runtime template\n * @param {boolean|undefined|null=} asiSafe asi safe (undefined: unknown, null: unneeded)\n * @returns {string} code converted to string that evaluates\n */\nconst stringifyObj = (\n\tobj,\n\tparser,\n\tvalueCacheVersions,\n\tkey,\n\truntimeTemplate,\n\tasiSafe\n) => {\n\tlet code;\n\tlet arr = Array.isArray(obj);\n\tif (arr) {\n\t\tcode = `[${obj\n\t\t\t.map(code =>\n\t\t\t\ttoCode(code, parser, valueCacheVersions, key, runtimeTemplate, null)\n\t\t\t)\n\t\t\t.join(\",\")}]`;\n\t} else {\n\t\tcode = `{${Object.keys(obj)\n\t\t\t.map(key => {\n\t\t\t\tconst code = obj[key];\n\t\t\t\treturn (\n\t\t\t\t\tJSON.stringify(key) +\n\t\t\t\t\t\":\" +\n\t\t\t\t\ttoCode(code, parser, valueCacheVersions, key, runtimeTemplate, null)\n\t\t\t\t);\n\t\t\t})\n\t\t\t.join(\",\")}}`;\n\t}\n\n\tswitch (asiSafe) {\n\t\tcase null:\n\t\t\treturn code;\n\t\tcase true:\n\t\t\treturn arr ? code : `(${code})`;\n\t\tcase false:\n\t\t\treturn arr ? `;${code}` : `;(${code})`;\n\t\tdefault:\n\t\t\treturn `/*#__PURE__*/Object(${code})`;\n\t}\n};\n\n/**\n * Convert code to a string that evaluates\n * @param {CodeValue} code Code to evaluate\n * @param {JavascriptParser} parser Parser\n * @param {Map<string, string | Set<string>>} valueCacheVersions valueCacheVersions\n * @param {string} key the defined key\n * @param {RuntimeTemplate} runtimeTemplate the runtime template\n * @param {boolean|undefined|null=} asiSafe asi safe (undefined: unknown, null: unneeded)\n * @returns {string} code converted to string that evaluates\n */\nconst toCode = (\n\tcode,\n\tparser,\n\tvalueCacheVersions,\n\tkey,\n\truntimeTemplate,\n\tasiSafe\n) => {\n\tif (code === null) {\n\t\treturn \"null\";\n\t}\n\tif (code === undefined) {\n\t\treturn \"undefined\";\n\t}\n\tif (Object.is(code, -0)) {\n\t\treturn \"-0\";\n\t}\n\tif (code instanceof RuntimeValue) {\n\t\treturn toCode(\n\t\t\tcode.exec(parser, valueCacheVersions, key),\n\t\t\tparser,\n\t\t\tvalueCacheVersions,\n\t\t\tkey,\n\t\t\truntimeTemplate,\n\t\t\tasiSafe\n\t\t);\n\t}\n\tif (code instanceof RegExp && code.toString) {\n\t\treturn code.toString();\n\t}\n\tif (typeof code === \"function\" && code.toString) {\n\t\treturn \"(\" + code.toString() + \")\";\n\t}\n\tif (typeof code === \"object\") {\n\t\treturn stringifyObj(\n\t\t\tcode,\n\t\t\tparser,\n\t\t\tvalueCacheVersions,\n\t\t\tkey,\n\t\t\truntimeTemplate,\n\t\t\tasiSafe\n\t\t);\n\t}\n\tif (typeof code === \"bigint\") {\n\t\treturn runtimeTemplate.supportsBigIntLiteral()\n\t\t\t? `${code}n`\n\t\t\t: `BigInt(\"${code}\")`;\n\t}\n\treturn code + \"\";\n};\n\nconst toCacheVersion = code => {\n\tif (code === null) {\n\t\treturn \"null\";\n\t}\n\tif (code === undefined) {\n\t\treturn \"undefined\";\n\t}\n\tif (Object.is(code, -0)) {\n\t\treturn \"-0\";\n\t}\n\tif (code instanceof RuntimeValue) {\n\t\treturn code.getCacheVersion();\n\t}\n\tif (code instanceof RegExp && code.toString) {\n\t\treturn code.toString();\n\t}\n\tif (typeof code === \"function\" && code.toString) {\n\t\treturn \"(\" + code.toString() + \")\";\n\t}\n\tif (typeof code === \"object\") {\n\t\tconst items = Object.keys(code).map(key => ({\n\t\t\tkey,\n\t\t\tvalue: toCacheVersion(code[key])\n\t\t}));\n\t\tif (items.some(({ value }) => value === undefined)) return undefined;\n\t\treturn `{${items.map(({ key, value }) => `${key}: ${value}`).join(\", \")}}`;\n\t}\n\tif (typeof code === \"bigint\") {\n\t\treturn `${code}n`;\n\t}\n\treturn code + \"\";\n};\n\nconst VALUE_DEP_PREFIX = \"webpack/DefinePlugin \";\nconst VALUE_DEP_MAIN = \"webpack/DefinePlugin_hash\";\n\nclass DefinePlugin {\n\t/**\n\t * Create a new define plugin\n\t * @param {Record<string, CodeValue>} definitions A map of global object definitions\n\t */\n\tconstructor(definitions) {\n\t\tthis.definitions = definitions;\n\t}\n\n\t/**\n\t * @param {function({ module: NormalModule, key: string, readonly version: string | undefined }): CodeValuePrimitive} fn generator function\n\t * @param {true | string[] | RuntimeValueOptions=} options options\n\t * @returns {RuntimeValue} runtime value\n\t */\n\tstatic runtimeValue(fn, options) {\n\t\treturn new RuntimeValue(fn, options);\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst definitions = this.definitions;\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"DefinePlugin\",\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tConstDependency,\n\t\t\t\t\tnew ConstDependency.Template()\n\t\t\t\t);\n\t\t\t\tconst { runtimeTemplate } = compilation;\n\n\t\t\t\tconst mainHash = createHash(compilation.outputOptions.hashFunction);\n\t\t\t\tmainHash.update(\n\t\t\t\t\t/** @type {string} */ (\n\t\t\t\t\t\tcompilation.valueCacheVersions.get(VALUE_DEP_MAIN)\n\t\t\t\t\t) || \"\"\n\t\t\t\t);\n\n\t\t\t\t/**\n\t\t\t\t * Handler\n\t\t\t\t * @param {JavascriptParser} parser Parser\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\tconst handler = parser => {\n\t\t\t\t\tconst mainValue = compilation.valueCacheVersions.get(VALUE_DEP_MAIN);\n\t\t\t\t\tparser.hooks.program.tap(\"DefinePlugin\", () => {\n\t\t\t\t\t\tconst { buildInfo } = parser.state.module;\n\t\t\t\t\t\tif (!buildInfo.valueDependencies)\n\t\t\t\t\t\t\tbuildInfo.valueDependencies = new Map();\n\t\t\t\t\t\tbuildInfo.valueDependencies.set(VALUE_DEP_MAIN, mainValue);\n\t\t\t\t\t});\n\n\t\t\t\t\tconst addValueDependency = key => {\n\t\t\t\t\t\tconst { buildInfo } = parser.state.module;\n\t\t\t\t\t\tbuildInfo.valueDependencies.set(\n\t\t\t\t\t\t\tVALUE_DEP_PREFIX + key,\n\t\t\t\t\t\t\tcompilation.valueCacheVersions.get(VALUE_DEP_PREFIX + key)\n\t\t\t\t\t\t);\n\t\t\t\t\t};\n\n\t\t\t\t\tconst withValueDependency =\n\t\t\t\t\t\t(key, fn) =>\n\t\t\t\t\t\t(...args) => {\n\t\t\t\t\t\t\taddValueDependency(key);\n\t\t\t\t\t\t\treturn fn(...args);\n\t\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Walk definitions\n\t\t\t\t\t * @param {Object} definitions Definitions map\n\t\t\t\t\t * @param {string} prefix Prefix string\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst walkDefinitions = (definitions, prefix) => {\n\t\t\t\t\t\tObject.keys(definitions).forEach(key => {\n\t\t\t\t\t\t\tconst code = definitions[key];\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tcode &&\n\t\t\t\t\t\t\t\ttypeof code === \"object\" &&\n\t\t\t\t\t\t\t\t!(code instanceof RuntimeValue) &&\n\t\t\t\t\t\t\t\t!(code instanceof RegExp)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\twalkDefinitions(code, prefix + key + \".\");\n\t\t\t\t\t\t\t\tapplyObjectDefine(prefix + key, code);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tapplyDefineKey(prefix, key);\n\t\t\t\t\t\t\tapplyDefine(prefix + key, code);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply define key\n\t\t\t\t\t * @param {string} prefix Prefix\n\t\t\t\t\t * @param {string} key Key\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst applyDefineKey = (prefix, key) => {\n\t\t\t\t\t\tconst splittedKey = key.split(\".\");\n\t\t\t\t\t\tsplittedKey.slice(1).forEach((_, i) => {\n\t\t\t\t\t\t\tconst fullKey = prefix + splittedKey.slice(0, i + 1).join(\".\");\n\t\t\t\t\t\t\tparser.hooks.canRename.for(fullKey).tap(\"DefinePlugin\", () => {\n\t\t\t\t\t\t\t\taddValueDependency(key);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply Code\n\t\t\t\t\t * @param {string} key Key\n\t\t\t\t\t * @param {CodeValue} code Code\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst applyDefine = (key, code) => {\n\t\t\t\t\t\tconst originalKey = key;\n\t\t\t\t\t\tconst isTypeof = /^typeof\\s+/.test(key);\n\t\t\t\t\t\tif (isTypeof) key = key.replace(/^typeof\\s+/, \"\");\n\t\t\t\t\t\tlet recurse = false;\n\t\t\t\t\t\tlet recurseTypeof = false;\n\t\t\t\t\t\tif (!isTypeof) {\n\t\t\t\t\t\t\tparser.hooks.canRename.for(key).tap(\"DefinePlugin\", () => {\n\t\t\t\t\t\t\t\taddValueDependency(originalKey);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tparser.hooks.evaluateIdentifier\n\t\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t\t.tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t * this is needed in case there is a recursion in the DefinePlugin\n\t\t\t\t\t\t\t\t\t * to prevent an endless recursion\n\t\t\t\t\t\t\t\t\t * e.g.: new DefinePlugin({\n\t\t\t\t\t\t\t\t\t * \"a\": \"b\",\n\t\t\t\t\t\t\t\t\t * \"b\": \"a\"\n\t\t\t\t\t\t\t\t\t * });\n\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\tif (recurse) return;\n\t\t\t\t\t\t\t\t\taddValueDependency(originalKey);\n\t\t\t\t\t\t\t\t\trecurse = true;\n\t\t\t\t\t\t\t\t\tconst res = parser.evaluate(\n\t\t\t\t\t\t\t\t\t\ttoCode(\n\t\t\t\t\t\t\t\t\t\t\tcode,\n\t\t\t\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\t\t\tcompilation.valueCacheVersions,\n\t\t\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t\t\t\truntimeTemplate,\n\t\t\t\t\t\t\t\t\t\t\tnull\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\trecurse = false;\n\t\t\t\t\t\t\t\t\tres.setRange(expr.range);\n\t\t\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tparser.hooks.expression.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\t\taddValueDependency(originalKey);\n\t\t\t\t\t\t\t\tconst strCode = toCode(\n\t\t\t\t\t\t\t\t\tcode,\n\t\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\tcompilation.valueCacheVersions,\n\t\t\t\t\t\t\t\t\toriginalKey,\n\t\t\t\t\t\t\t\t\truntimeTemplate,\n\t\t\t\t\t\t\t\t\t!parser.isAsiPosition(expr.range[0])\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (/__webpack_require__\\s*(!?\\.)/.test(strCode)) {\n\t\t\t\t\t\t\t\t\treturn toConstantDependency(parser, strCode, [\n\t\t\t\t\t\t\t\t\t\tRuntimeGlobals.require\n\t\t\t\t\t\t\t\t\t])(expr);\n\t\t\t\t\t\t\t\t} else if (/__webpack_require__/.test(strCode)) {\n\t\t\t\t\t\t\t\t\treturn toConstantDependency(parser, strCode, [\n\t\t\t\t\t\t\t\t\t\tRuntimeGlobals.requireScope\n\t\t\t\t\t\t\t\t\t])(expr);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn toConstantDependency(parser, strCode)(expr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser.hooks.evaluateTypeof.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * this is needed in case there is a recursion in the DefinePlugin\n\t\t\t\t\t\t\t * to prevent an endless recursion\n\t\t\t\t\t\t\t * e.g.: new DefinePlugin({\n\t\t\t\t\t\t\t * \"typeof a\": \"typeof b\",\n\t\t\t\t\t\t\t * \"typeof b\": \"typeof a\"\n\t\t\t\t\t\t\t * });\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (recurseTypeof) return;\n\t\t\t\t\t\t\trecurseTypeof = true;\n\t\t\t\t\t\t\taddValueDependency(originalKey);\n\t\t\t\t\t\t\tconst codeCode = toCode(\n\t\t\t\t\t\t\t\tcode,\n\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\tcompilation.valueCacheVersions,\n\t\t\t\t\t\t\t\toriginalKey,\n\t\t\t\t\t\t\t\truntimeTemplate,\n\t\t\t\t\t\t\t\tnull\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst typeofCode = isTypeof\n\t\t\t\t\t\t\t\t? codeCode\n\t\t\t\t\t\t\t\t: \"typeof (\" + codeCode + \")\";\n\t\t\t\t\t\t\tconst res = parser.evaluate(typeofCode);\n\t\t\t\t\t\t\trecurseTypeof = false;\n\t\t\t\t\t\t\tres.setRange(expr.range);\n\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.typeof.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\taddValueDependency(originalKey);\n\t\t\t\t\t\t\tconst codeCode = toCode(\n\t\t\t\t\t\t\t\tcode,\n\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\tcompilation.valueCacheVersions,\n\t\t\t\t\t\t\t\toriginalKey,\n\t\t\t\t\t\t\t\truntimeTemplate,\n\t\t\t\t\t\t\t\tnull\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst typeofCode = isTypeof\n\t\t\t\t\t\t\t\t? codeCode\n\t\t\t\t\t\t\t\t: \"typeof (\" + codeCode + \")\";\n\t\t\t\t\t\t\tconst res = parser.evaluate(typeofCode);\n\t\t\t\t\t\t\tif (!res.isString()) return;\n\t\t\t\t\t\t\treturn toConstantDependency(\n\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\tJSON.stringify(res.string)\n\t\t\t\t\t\t\t).bind(parser)(expr);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply Object\n\t\t\t\t\t * @param {string} key Key\n\t\t\t\t\t * @param {Object} obj Object\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst applyObjectDefine = (key, obj) => {\n\t\t\t\t\t\tparser.hooks.canRename.for(key).tap(\"DefinePlugin\", () => {\n\t\t\t\t\t\t\taddValueDependency(key);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.evaluateIdentifier\n\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t.tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\t\taddValueDependency(key);\n\t\t\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t\t.setTruthy()\n\t\t\t\t\t\t\t\t\t.setSideEffects(false)\n\t\t\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.evaluateTypeof\n\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t.tap(\n\t\t\t\t\t\t\t\t\"DefinePlugin\",\n\t\t\t\t\t\t\t\twithValueDependency(key, evaluateToString(\"object\"))\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tparser.hooks.expression.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\taddValueDependency(key);\n\t\t\t\t\t\t\tconst strCode = stringifyObj(\n\t\t\t\t\t\t\t\tobj,\n\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\tcompilation.valueCacheVersions,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\truntimeTemplate,\n\t\t\t\t\t\t\t\t!parser.isAsiPosition(expr.range[0])\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif (/__webpack_require__\\s*(!?\\.)/.test(strCode)) {\n\t\t\t\t\t\t\t\treturn toConstantDependency(parser, strCode, [\n\t\t\t\t\t\t\t\t\tRuntimeGlobals.require\n\t\t\t\t\t\t\t\t])(expr);\n\t\t\t\t\t\t\t} else if (/__webpack_require__/.test(strCode)) {\n\t\t\t\t\t\t\t\treturn toConstantDependency(parser, strCode, [\n\t\t\t\t\t\t\t\t\tRuntimeGlobals.requireScope\n\t\t\t\t\t\t\t\t])(expr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn toConstantDependency(parser, strCode)(expr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.typeof\n\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t.tap(\n\t\t\t\t\t\t\t\t\"DefinePlugin\",\n\t\t\t\t\t\t\t\twithValueDependency(\n\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t\ttoConstantDependency(parser, JSON.stringify(\"object\"))\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t};\n\n\t\t\t\t\twalkDefinitions(definitions, \"\");\n\t\t\t\t};\n\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/auto\")\n\t\t\t\t\t.tap(\"DefinePlugin\", handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/dynamic\")\n\t\t\t\t\t.tap(\"DefinePlugin\", handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/esm\")\n\t\t\t\t\t.tap(\"DefinePlugin\", handler);\n\n\t\t\t\t/**\n\t\t\t\t * Walk definitions\n\t\t\t\t * @param {Object} definitions Definitions map\n\t\t\t\t * @param {string} prefix Prefix string\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\tconst walkDefinitionsForValues = (definitions, prefix) => {\n\t\t\t\t\tObject.keys(definitions).forEach(key => {\n\t\t\t\t\t\tconst code = definitions[key];\n\t\t\t\t\t\tconst version = toCacheVersion(code);\n\t\t\t\t\t\tconst name = VALUE_DEP_PREFIX + prefix + key;\n\t\t\t\t\t\tmainHash.update(\"|\" + prefix + key);\n\t\t\t\t\t\tconst oldVersion = compilation.valueCacheVersions.get(name);\n\t\t\t\t\t\tif (oldVersion === undefined) {\n\t\t\t\t\t\t\tcompilation.valueCacheVersions.set(name, version);\n\t\t\t\t\t\t} else if (oldVersion !== version) {\n\t\t\t\t\t\t\tconst warning = new WebpackError(\n\t\t\t\t\t\t\t\t`DefinePlugin\\nConflicting values for '${prefix + key}'`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\twarning.details = `'${oldVersion}' !== '${version}'`;\n\t\t\t\t\t\t\twarning.hideStack = true;\n\t\t\t\t\t\t\tcompilation.warnings.push(warning);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tcode &&\n\t\t\t\t\t\t\ttypeof code === \"object\" &&\n\t\t\t\t\t\t\t!(code instanceof RuntimeValue) &&\n\t\t\t\t\t\t\t!(code instanceof RegExp)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\twalkDefinitionsForValues(code, prefix + key + \".\");\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t};\n\n\t\t\t\twalkDefinitionsForValues(definitions, \"\");\n\n\t\t\t\tcompilation.valueCacheVersions.set(\n\t\t\t\t\tVALUE_DEP_MAIN,\n\t\t\t\t\t/** @type {string} */ (mainHash.digest(\"hex\").slice(0, 8))\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = DefinePlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}